<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>LogBird Map Viewer</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png">
  <link rel="stylesheet" href="/public/styles.css">

</head>
<body>
  <div class="container">
    <div class="topnav">
        <div class="top-bar">
            <div class="left-section">
              <a href="/">Home</a>
              <span>/</span>
              <strong>Map</strong>
              <span>/</span>
              <a href="/graph">Graphs</a>
              <span>/</span>
              <a href="/side">Side by Side</a>
              <span>/</span>
              <a href="/settings">Settings</a>
            </div>

            <div class="center-section">
              <h1>LogBird Map Viewer</h1>
            </div>

            <div class="right-section">
                <button id="btnWin" class="btn btn-win">Record Win</button>
                <button id="btnLoss" class="btn btn-loss">Record Loss</button>
                <button id="btnPostLogs" class="btn">Post Logs</button>
                <button id="btnSubmitJson" class="btn">Submit JSON</button>
                <button id="btnReset" class="btn">Reset</button>
            </div>
          </div>

    <div class="main-content">
      <div class="map-container">
        <div id="map-root" class="panel">
          <div class="map-wrapper">
            <canvas id="map-canvas">Please use a browser with canvas support</canvas>
          </div>
          <div class="section-bar" style="margin-top: 6px;">
            <div class="left-section">
              <span>Source: <code>/api/map-img?gen=7</code></span>
              <button id="btnRefresh" class="btn">Refresh</button>
              <label class="checkbox-label">
                <input id="chkAuto" type="checkbox" checked>
                Auto-refresh
              </label>
            </div>
            <div class="right-section">
              <span>View:</span>
              <button id="btnZoomIn" class="btn">+</button>
              <button id="btnZoomOut" class="btn">-</button>
              <button id="btnReset" class="btn">Reset</button>
              <button id="btnMeasure" class="btn">Measure Distance</button>
            </div>
          </div>
        </div>
      </div>
      
      <div class="sidebar">
        
        <div class="panel">
          <label>Squad No: <input id="inpSquadNo" class="meta-input" type="text" placeholder="e.g. 123" /></label>
          <label>GC: <input id="inpGC" class="meta-input" type="text" placeholder="e.g. GC" /></label>
          <label>AC: <input id="inpAC" class="meta-input" type="text" placeholder="e.g. AC" /></label>
          <button id="btnSaveMeta" class="btn">Save</button>
          <script>
            // Fetch and display meta for the selected game
            async function fetchMetaForSelectedGame() {
              const gameSel = document.getElementById('filterGameR');
              let game = gameSel ? gameSel.value : 'current';
              if (game === 'current') {
                try { 
                  const current = (await (await fetch('/api/current-game')).json()).currentGame;
                  game = String(current); 
                } catch (_) {}
              }
              try {
                const res = await fetch('/api/meta' + (game && game !== 'all' ? ('?game=' + encodeURIComponent(game)) : ''));
                const j = await res.json();
                const meta = { squadNo: '', gc: '', ac: '', ...(j.meta || {}) };
                // Update input fields
                const iSquad = document.getElementById('inpSquadNo');
                const iGc = document.getElementById('inpGC');
                const iAc = document.getElementById('inpAC');
                if (iSquad) iSquad.value = meta.squadNo || '';
                if (iGc) iGc.value = meta.gc || '';
                if (iAc) iAc.value = meta.ac || '';
              } catch (_) {
                // Keep current values on error
              }
            }

            // Save meta for the selected game
            async function saveMetaForSelectedGame() {
              const gameSel = document.getElementById('filterGameR');
              let game = gameSel ? gameSel.value : 'current';
              if (game === 'current' || game === 'all') {
                try { 
                  const current = (await (await fetch('/api/current-game')).json()).currentGame;
                  game = String(current); 
                } catch (_) {}
              }
              const payload = {
                squadNo: document.getElementById('inpSquadNo')?.value || '',
                gc: document.getElementById('inpGC')?.value || '',
                ac: document.getElementById('inpAC')?.value || ''
              };
              try {
                await fetch('/api/meta?game=' + encodeURIComponent(game), { 
                  method: 'POST', 
                  headers: { 'Content-Type': 'application/json' }, 
                  body: JSON.stringify(payload) 
                });
                await fetchMetaForSelectedGame();
                // Refresh the data after saving
                const rows = await fetchRowsForGameR(gameSel.value);
                renderCurrentGameTableR(rows);
                applyFiltersAndRenderR();
              } catch (_) {}
            }

            // Wire up save button
            document.addEventListener('DOMContentLoaded', () => {
              const btnSave = document.getElementById('btnSaveMeta');
              if (btnSave) {
                btnSave.addEventListener('click', saveMetaForSelectedGame);
              }
              
              // Also load meta when game selection changes
              const gameSel = document.getElementById('filterGameR');
              if (gameSel) {
                gameSel.addEventListener('change', fetchMetaForSelectedGame);
              }
              
              // Initial load
              fetchMetaForSelectedGame();
            });
          </script>
        </div>
          <div class="panel">
            <div class="section-bar" style="display: flex; justify-content: space-between;">
                <div class="left-section">
                <h2 class="no-top">Current Game</h2>
                </div>
                <div class="right-section">
                    <div class="game-switcher">
                        <button id="btnPrevGameR" class="btn-stealth" title="Previous game" type="button">◀</button>
                        <select id="filterGameR"></select>
                        <button id="btnNextGameR" class="btn-stealth" title="Next game" type="button">▶</button>
                    </div>
                </div>
            </div>
            
            <!-- Filters moved to table headers below -->
            <div class="scrollable-table bordered">
              <table>
                <thead>
                  <tr>
                    <th class="sticky-th compact-head">
                      <select id="filterSquadronR" class="compact-select">
                        <option value="all">All</option>
                      </select>
                    </th>
                    <th class="sticky-th compact-head">
                      <select id="filterPlayerR" class="compact-select">
                        <option value="all">All</option>
                      </select>
                    </th>
                    <th class="sticky-th compact-head">
                      <select id="filterVehicleR" class="compact-select">
                        <option value="all">All</option>
                      </select>
                    </th>
                    <th class="sticky-th compact-head">
                      <div class="btn-row-compact">
                        <button id="btnStatusAliveR" class="btn btn-alive btn-compact" type="button" title="Show Active (click again to clear filter)">A</button>
                        <button id="btnStatusDestroyedR" class="btn btn-destroyed btn-compact" type="button" title="Show Destroyed (click again to clear filter)">D</button>
                      </div>
                    </th>
                    <th class="sticky-th">Kills</th>
                  </tr>
                </thead>
                <tbody id="curGameTableBody"><tr><td colspan="7" class="muted">Loading...</td></tr></tbody>
              </table>
            </div>
          </div>
          <div class="panel">
            <h2 class="section-title">Game Logs</h2>
            <div class="scrollable-table bordered">
              <table class="mono-table">
                <tbody id="rightAllGamesSummaryBody"><tr><td style="color:#888;">Loading...</td></tr></tbody>
              </table>
            </div>
        </div>
      </div>
    </div>
    
    <!--
      .main-content {
        display: flex;
        flex: 1;
        gap: 20px;
        min-height: 0;
      }
      
      .map-container {
        flex: 1;
        min-width: 50%;
        display: flex;
        flex-direction: column;
      }
      
      .map-wrapper {
        flex: 1;
        min-height: 400px;
        min-width: 400px;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #000;
      }      
      
      .sidebar {
        min-width: 300px;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      
      #map-canvas {
        max-width: 100%;
        max-height: 100%;
        width: auto !important;
        height: auto !important;
        display: block;
        user-select: none;
        touch-action: none;
      }
      
      .map-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 12px;
        align-items: center;
        justify-content: space-between;
      }
      
      .control-group {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      

      
      .scrollable-table {
        max-height: calc(2.1em * 16 + 2px); /* 16 lines of text + borders */
        overflow-y: auto;
        border: 1px solid var(--border-color);
        border-radius: 4px;
      }
      
      .scrollable-table table {
        width: 100%;
        border-collapse: collapse;
        margin: 0;
      }
      
      .scrollable-table thead th {
        position: sticky;
        top: 0;
        background: var(--panel-bg);
        z-index: 1;
      }
      
      .scrollable-table tbody tr {
        height: 1.5em;
      }
      
      /* Responsive adjustments */
      @media (max-width: 1200px) {
        .main-content {
          flex-direction: column;
        }
        
        .sidebar {
          width: 100%;
          min-width: 0;
        }
        
        .map-wrapper {
          min-height: 70vh;
        }
        
        .filters {
          flex-direction: column;
          align-items: stretch;
        }
        
        .filters > * {
          width: 100%;
        }
      }
      
      @media (max-width: 768px) {
        .container {
          padding: 10px;
        }
        
        .map-controls {
          flex-direction: column;
          align-items: flex-start;
        }
      }
    -->
  </div>
  <script>
    (function(){
      'use strict';
      
      // Main application code
      
      // Initialize the application
      function initApplication() {
        // Set up event listeners
        const btnRefresh = document.getElementById('btnRefresh');
        if (btnRefresh) {
          btnRefresh.addEventListener('click', () => { 
            loadMapImageOnce(); 
            refreshObjects(); 
          });
        }
        
        const chk = document.getElementById('chkAuto');
        if (chk) {
          chk.addEventListener('change', () => {
            if (chk.checked) startAuto(); 
            else stopAuto();
          });
        }

        // Set up resize handler
        window.addEventListener('resize', resizeCanvas);
        
        // Initial setup
        resizeCanvas();
        refreshInfo();
        loadMapImageOnce();
        refreshObjects();
        loadExistingTracks();
        startAuto();
        startPersist();
        
        // Initialize right column
        initRightControls();
        refreshRightAllGamesSummary();
        
        // Periodic refresh every 5s
        setInterval(async () => { 
          const sel = document.getElementById('filterGameR'); 
          if (sel) { 
            await fetchRowsForGameR(sel.value); 
            applyFiltersAndRenderR(); 
          } 
        }, 5000);
        
        setInterval(refreshRightAllGamesSummary, 7000);
      }
      
      // Save on unload using sendBeacon
      window.addEventListener('beforeunload', () => {
        try {
          const arr = serializeTracks();
          if (!arr.length) return;
          const blob = new Blob([JSON.stringify({ tracks: arr })], { type: 'application/json' });
          navigator.sendBeacon('/api/map-tracks', blob);
        } catch (_) { /* ignore */ }
      });
      
      // Initialize when DOM is loaded
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initApplication);
      } else {
        initApplication();
      }
      // Highlight colors for players and squadrons
      let highlights = { players: {}, squadrons: {} };
      
      // Function to get color pair for highlighting
      function getColorPair(entry) {
        // Accept either string (treated as background) or object { bg, fg }
        if (!entry) return { bg: '', fg: '' };
        if (typeof entry === 'string') return { bg: entry, fg: '' };
        return { bg: entry.bg || '', fg: entry.fg || '' };
      }
      
      // Load highlight colors for players and squadrons
      async function fetchHighlights() {
        try {
          const resp = await fetch('/api/highlights');
          const data = await resp.json();
          if (data && typeof data === 'object') {
            highlights = {
              players: data.players || {},
              squadrons: data.squadrons || {}
            };
          }
        } catch (_) { /* keep defaults */ }
      }
      const canvas = document.getElementById('map-canvas');
      const ctx = canvas.getContext('2d');
      const URL_BASE = '/api/map-img?gen='; // we'll append map_generation
      const URL_INFO = '/api/map-info';
      const URL_OBJECTS = '/api/map-objects';
      let timer = null;
      let objTimer = null;
      let mapImg = null;
      let mapInfo = null; // {minX,maxX,minY,maxY, gridSteps:[gx,gy], mapGen}
      const view = { scale: 1, offsetX: 0, offsetY: 0 };
      const limits = { minScale: 1, maxScale: 8 };
      let dragging = false, dragStart = { x:0, y:0 }, startOffset = { x:0, y:0 };
      const state = { objects: [] };
      // blink timers (to mimic localhost.htm behaviour)
      let lastT = null, blinkNormalT = 0, blinkHeavyT = 0, blinkNormalVal = 0, blinkHeavyVal = 0;
      // movement tracking (ID-less correlation)
      const tracks = new Map(); // key: trackId (string) -> {points:[{x,y}], color, meta, lastSeen}
      let nextTrackId = 1;
      const TRACK_MAX_POINTS = 2000; // cap for memory
      const MATCH_MAX_DIST = 0.01; // max normalized distance to associate (~3.5% of map)
      const MOVEMENT_EPS = 0.001; // minimum normalized move to record a new point
      // Tracks persist indefinitely; we will clear them when map generation changes
      // const TRACK_TTL_MS = 2 * 60 * 1000;
      // Prediction/correlation tuning
      const PRED_MAX_SECS = 2.0;        // cap time gap used for prediction
      const MAX_SPEED_NORM = 0.05;       // clamp speed (normalized units per second)
      const PRED_GAIN = 1.0;            // scale applied to velocity during prediction
      // Assignment/cost tuning
      const USE_HUNGARIAN = true;       // switch to global optimal assignment
      const DIR_PENALTY_GAIN = 0.5;     // weight for direction penalty (0..1 typical)

      // Clamp pan so the map image never leaves canvas area.
      // When scale == 1, pan is locked at 0,0. When scale > 1, allow panning within image bounds.
      function clampView(){
        const s = Math.max(limits.minScale, Math.min(view.scale, limits.maxScale));
        const w = canvas.width, h = canvas.height;
        const minX = w - w * s; // negative or 0
        const minY = h - h * s;
        // Lock to [min, 0]
        view.scale = s;
        if (view.offsetX < minX) view.offsetX = minX;
        if (view.offsetX > 0) view.offsetX = 0;
        if (view.offsetY < minY) view.offsetY = minY;
        if (view.offsetY > 0) view.offsetY = 0;
      }

      // --- Helpers: prediction and math ---
      function predictTrack(tr, now){
        const n = tr.points.length;
        const last = tr.points[n-1];
        const prev = n >= 2 ? tr.points[n-2] : null;
        let px = last.x, py = last.y, vx = 0, vy = 0, hasVel = false;
        if (prev && Number.isFinite(last.t) && Number.isFinite(prev.t)) {
          const dt = Math.max(0.001, (last.t - prev.t) * 0.001);
          vx = (last.x - prev.x) / dt; vy = (last.y - prev.y) / dt;
          const vlen = Math.hypot(vx, vy);
          if (vlen > 0) {
            const vmax = MAX_SPEED_NORM;
            if (vlen > vmax) { const k = vmax / vlen; vx *= k; vy *= k; }
            const dtNow = Math.min(PRED_MAX_SECS, Math.max(0, (now - (Number.isFinite(last.t) ? last.t : now)) * 0.001));
            px = last.x + vx * dtNow * PRED_GAIN;
            py = last.y + vy * dtNow * PRED_GAIN;
            hasVel = true;
          }
        }
        return { px, py, vx, vy, hasVel, last };
      }

      function dirPenalty(vx, vy, fromx, fromy, tox, toy){
        // penalty in [0,2]; 0 if directions align, ~1 if orthogonal, 2 if opposite
        const ax = tox - fromx, ay = toy - fromy;
        const al = Math.hypot(ax, ay);
        const vl = Math.hypot(vx, vy);
        if (al <= 1e-6 || vl <= 1e-6) return 0;
        const dot = (ax*vx + ay*vy) / (al * vl);
        const c = Math.max(-1, Math.min(1, dot));
        return (1 - c) * 1.0; // 0 align, 2 opposite after scaling by 2 if desired
      }

      // Minimal Hungarian Algorithm for rectangular cost matrices
      // Returns array of column index for each row, or -1 if unassigned
      function hungarian(cost) {
        const nRows = cost.length;
        const nCols = cost[0]?.length || 0;
        const n = Math.max(nRows, nCols);
        // Build square matrix filled with large cost
        const INF = 1e9;
        const a = Array.from({length:n}, (_, i) =>
          Array.from({length:n}, (_, j) => (i < nRows && j < nCols ? cost[i][j] : 0))
        );
        const u = Array(n+1).fill(0), v = Array(n+1).fill(0), p = Array(n+1).fill(0), way = Array(n+1).fill(0);
        for (let i = 1; i <= n; i++) {
          p[0] = i;
          let j0 = 0;
          const minv = Array(n+1).fill(INF);
          const used = Array(n+1).fill(false);
          do {
            used[j0] = true;
            const i0 = p[j0];
            let delta = INF, j1 = 0;
            for (let j = 1; j <= n; j++) if (!used[j]) {
              const cur = a[i0-1][j-1] - u[i0] - v[j];
              if (cur < minv[j]) { minv[j] = cur; way[j] = j0; }
              if (minv[j] < delta) { delta = minv[j]; j1 = j; }
            }
            for (let j = 0; j <= n; j++) {
              if (used[j]) { u[p[j]] += delta; v[j] -= delta; }
              else { minv[j] -= delta; }
            }
            j0 = j1;
          } while (p[j0] !== 0);
          do {
            const j1 = way[j0];
            p[j0] = p[j1];
            j0 = j1;
          } while (j0 !== 0);
        }
        const ans = Array(nRows).fill(-1);
        for (let j = 1; j <= n; j++) if (p[j] > 0 && p[j] <= nRows && j <= nCols) {
          ans[p[j]-1] = j-1;
        }
        return ans;
      }

      // Icon cache and loader for drawing object-specific icons
      const iconCache = new Map(); // name -> Image|null (null marks missing)
      function requestIcon(name){
        if (!name) return null;
        if (iconCache.has(name)) return iconCache.get(name);
        const img = new Image();
        img.onload = () => { iconCache.set(name, img); try { render(); } catch (_) {} };
        img.onerror = () => { iconCache.set(name, null); };
        img.src = `/public/icons/${encodeURIComponent(name)}.png`;
        iconCache.set(name, img); // provisional while loading
        return img;
      }

      function drawDiamond(cx, cy, r, fill, stroke){
        ctx.save();
        ctx.fillStyle = fill || '#ccc';
        ctx.strokeStyle = stroke || '#000';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx, cy - r);
        ctx.lineTo(cx + r, cy);
        ctx.lineTo(cx, cy + r);
        ctx.lineTo(cx - r, cy);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }

      function drawFlatRect(cx, cy, h, ratio, fill, stroke){
        // Draw a centered rectangle with height=h and width=h*ratio
        const w = h * (ratio || 4);
        ctx.save();
        ctx.fillStyle = fill || '#ccc';
        ctx.strokeStyle = stroke || '#000';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.rect(cx - w*0.5, cy - h*0.5, w, h);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }

      function drawInvertedUSquare(cx, cy, unit, fill, stroke){
        // Upside-down U made of three rectangles (top bar + two legs)
        // Outer size ratio H:W = 2:4, thickness T = 1 unit
        const T = unit;
        const H = 2 * unit;
        const W = 4 * unit;
        const topX = cx - W * 0.5;
        const topY = cy - H * 0.5;
        const legH = H - T;
        ctx.save();
        ctx.fillStyle = fill || '#ccc';
        ctx.strokeStyle = stroke || '#000';
        ctx.lineWidth = 1;
        // top bar
        ctx.fillRect(topX, topY, W, T);
        ctx.strokeRect(topX, topY, W, T);
        // left leg
        ctx.fillRect(topX, topY + T, T, legH);
        ctx.strokeRect(topX, topY + T, T, legH);
        // right leg
        const rightX = cx + W * 0.5 - T;
        ctx.fillRect(rightX, topY + T, T, legH);
        ctx.strokeRect(rightX, topY + T, T, legH);
        ctx.restore();
      }

      function drawHeavyTankShape(cx, cy, unit, fill, stroke){
        // Base: inverted U
        drawInvertedUSquare(cx, cy, unit, fill, stroke);
        // Add top centered 1x1 unit square above the top bar
        const T = unit;
        const H = 2 * unit;
        const W = 4 * unit;
        const topX = cx - W * 0.5;
        const topY = cy - H * 0.5;
        const sqSize = unit;
        const sqX = cx - sqSize * 0.5;
        const sqY = topY - sqSize; // directly above top bar
        ctx.save();
        ctx.fillStyle = fill || '#ccc';
        ctx.strokeStyle = stroke || '#000';
        ctx.lineWidth = 1;
        ctx.fillRect(sqX, sqY, sqSize, sqSize);
        ctx.strokeRect(sqX, sqY, sqSize, sqSize);
        ctx.restore();
      }

      function drawSPAA(cx, cy, unit, fill, stroke){
        // Base: flat bar 1:4 (height=1*unit, width=4*unit)
        const T = unit;
        const W = 4 * unit;
        const topY = cy - T * 0.5;
        const leftX = cx - W * 0.5;
        ctx.save();
        ctx.fillStyle = fill || '#ccc';
        ctx.strokeStyle = stroke || '#000';
        ctx.lineWidth = 1;
        ctx.fillRect(leftX, topY, W, T);
        ctx.strokeRect(leftX, topY, W, T);
        // Two 1x1 squares equally spaced along the top
        const sq = unit;
        const ySq = topY - sq; // sitting on top of the bar
        const cx1 = cx - W * 0.25;
        const cx2 = cx + W * 0.25;
        ctx.fillRect(cx1 - sq * 0.5, ySq, sq, sq);
        ctx.strokeRect(cx1 - sq * 0.5, ySq, sq, sq);
        ctx.fillRect(cx2 - sq * 0.5, ySq, sq, sq);
        ctx.strokeRect(cx2 - sq * 0.5, ySq, sq, sq);
        ctx.restore();
      }

      // Resize canvas to the largest possible square that fits the container and viewport
      function resizeCanvas() {
        const mapRoot = document.getElementById('map-root');
        const container = mapRoot.parentElement; // .container
        const rectTop = mapRoot.getBoundingClientRect().top;
        const availW = container.clientWidth - 2; // minus borders
        const availH = window.innerHeight - rectTop - 20; // leave small bottom margin
        const newSize = Math.max(100, Math.floor(Math.min(availW, availH)));
        if (canvas.width === newSize && canvas.height === newSize) return;
        const oldW = canvas.width || newSize;
        const oldH = canvas.height || newSize;
        // scale offsets to keep view roughly in-place after resize
        const sx = newSize / oldW;
        const sy = newSize / oldH;
        view.offsetX *= sx;
        view.offsetY *= sy;
        canvas.width = newSize;
        canvas.height = newSize;
        canvas.style.width = newSize + 'px';
        canvas.style.height = newSize + 'px';
        clampView();
        render();
      }

      function drawPlaceholder(msg) {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ccc';
        ctx.font = '16px sans-serif';
        ctx.fillText(msg || 'No map image', 12, 24);
      }

      function setMapImageSrc(gen) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        const cacheBust = 'ts=' + Date.now();
        const genParam = (typeof gen === 'number' && !Number.isNaN(gen)) ? gen : 7;
        img.onload = function(){
          mapImg = img;
          render();
        };
        img.onerror = function(){
          // Keep rendering the previous image if available
          if (mapImg) {
            render();
          } else {
            drawPlaceholder('Failed to load map image');
          }
        };
        img.src = URL_BASE + genParam + '&' + cacheBust;
      }

      function loadMapImageOnce() {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        const cacheBust = 'ts=' + Date.now();
        img.onload = function(){
          mapImg = img;
          render();
        };
        img.onerror = function(){
          // Keep rendering the previous image if available
          if (mapImg) {
            render();
          } else {
            drawPlaceholder('Failed to load map image');
          }
        };
        // if we know mapGen, use it; else default to 7
        const genParam = (mapInfo && typeof mapInfo.mapGen === 'number') ? mapInfo.mapGen : 7;
        img.src = URL_BASE + genParam + '&' + cacheBust;
      }

      async function fetchJson(url) {
        try {
          const r = await fetch(url, { cache: 'no-store' });
          if (!r.ok) throw new Error(r.status + ' ' + r.statusText);
          return await r.json();
        } catch (e) { return null; }
      }

      async function refreshInfo() {
        const j = await fetchJson(URL_INFO);
        if (!j) return;
        const prevGen = (mapInfo && typeof mapInfo.mapGen === 'number') ? mapInfo.mapGen : -1;
        // Normalize
        const info = {};
        if ('map_min_x' in j) info.minX = j.map_min_x;
        if ('map_max_x' in j) info.maxX = j.map_max_x;
        if ('map_min_y' in j) info.minY = j.map_min_y;
        if ('map_max_y' in j) info.maxY = j.map_max_y;
        if (!('minX' in info) && j.min && typeof j.min.x === 'number') info.minX = j.min.x;
        if (!('maxX' in info) && j.max && typeof j.max.x === 'number') info.maxX = j.max.x;
        if (!('minY' in info) && j.min && typeof j.min.y === 'number') info.minY = j.min.y;
        if (!('maxY' in info) && j.max && typeof j.max.y === 'number') info.maxY = j.max.y;
        if (Array.isArray(j.map_min) && j.map_min.length >= 2) {
          info.minX = j.map_min[0];
          info.minY = j.map_min[1];
        }
        if (Array.isArray(j.map_max) && j.map_max.length >= 2) {
          info.maxX = j.map_max[0];
          info.maxY = j.map_max[1];
        }
        if (Array.isArray(j.grid_steps) && j.grid_steps.length >= 2) info.gridSteps = [j.grid_steps[0], j.grid_steps[1]];
        if (typeof j.map_generation === 'number') info.mapGen = j.map_generation;

        const valid = [info.minX, info.maxX, info.minY, info.maxY].every(v => typeof v === 'number');
        if (!valid) return;

        mapInfo = info;
        // If generation changed, reload image and reset view
        const newGen = (typeof info.mapGen === 'number') ? info.mapGen : prevGen;
        if (newGen !== prevGen) {
          // Clear tracks when background image (map generation) changes
          tracks.clear();
          nextTrackId = 1;
          setMapImageSrc(newGen);
          view.scale = 1; view.offsetX = 0; view.offsetY = 0;
        } else {
          render();
        }
      }

      // --- Persistence: serialize and POST tracks to server ---
      function serializeTracks() {
        const out = [];
        tracks.forEach((tr, tid) => {
          if (!tr || !Array.isArray(tr.points) || tr.points.length === 0) return;
          out.push({ id: String(tid), meta: tr.meta || '', color: tr.color || '#59a3ff', points: tr.points.map(p => ({ x: +p.x, y: +p.y, t: Number.isFinite(p.t) ? +p.t : undefined })) });
        });
        return out;
      }

      async function postTracks() {
        try {
          const arr = serializeTracks();
          // avoid spamming empty payloads
          if (!arr.length) return;
          await fetch('/api/map-tracks', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tracks: arr }),
            cache: 'no-store',
          });
        } catch (_) { /* ignore */ }
      }

      // Load existing persisted tracks once and merge
      async function loadExistingTracks() {
        try {
          const resp = await fetch('/api/map-tracks', { cache: 'no-store' });
          if (!resp.ok) return;
          const j = await resp.json();
          const arr = (j && Array.isArray(j.tracks)) ? j.tracks : [];
          for (const t of arr) {
            if (!t || !Array.isArray(t.points) || t.points.length === 0) continue;
            const key = (t.id != null ? String(t.id) : undefined);
            if (key && !tracks.has(key)) {
              tracks.set(key, {
                points: t.points.map(p => ({ x: +p.x, y: +p.y, t: Number.isFinite(p?.t) ? +p.t : undefined })),
                color: (typeof t.color === 'string' ? t.color : undefined),
                meta: (t.meta != null ? String(t.meta) : undefined),
              });
            }
          }
          render();
        } catch (_) { /* ignore */ }
      }

      async function refreshObjects() {
        const j = await fetchJson(URL_OBJECTS);
        if (!j) return;
        // Accept array or object with list field
        const arr = Array.isArray(j) ? j : (Array.isArray(j.objects) ? j.objects : []);
        state.objects = arr.filter(o => typeof o === 'object');
        render();
      }

      function worldToImage(x, y) {
        if (!mapInfo || !mapImg) return { x: 0, y: 0 };
        const minX = mapInfo.minX, maxX = mapInfo.maxX;
        const minY = mapInfo.minY, maxY = mapInfo.maxY;
        const iw = mapImg.naturalWidth || mapImg.width;
        const ih = mapImg.naturalHeight || mapImg.height;
        // Linear map. War Thunder Y usually increases upwards; map image origin is top-left.
        const nx = (x - minX) / (maxX - minX);
        const ny = (y - minY) / (maxY - minY);
        const px = nx * iw;
        const py = (1 - ny) * ih; // invert Y for top-left origin
        return { x: px, y: py };
      }

      function imageToView(px, py) {
        return {
          x: px * view.scale + view.offsetX,
          y: py * view.scale + view.offsetY,
        };
      }

      function lerp(a,b,t){ return a + (b-a)*t; }
      function rgbHex(r,g,b){ r=r|0; g=g|0; b=b|0; return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join(''); }
      function calcBlinkColor(item){
        if (item && item.blink) {
          const bv = (item.blink === 2 ? blinkHeavyVal : blinkNormalVal);
          const c0 = Array.isArray(item['color[]']) ? item['color[]'] : null;
          if (c0 && c0.length>=3) {
            const c1 = [255,255,0];
            return rgbHex(lerp(c0[0],c1[0],bv), lerp(c0[1],c1[1],bv), lerp(c0[2],c1[2],bv));
          }
        }
        return (item && typeof item.color === 'string') ? item.color : '#ff5252';
      }

      function updateBlinkTimers(){
        const t = Date.now();
        let dt = 0;
        if (lastT != null) {
          dt = (t - lastT) * 0.001;
          blinkNormalT += dt; blinkHeavyT += dt;
          const pN = 2.0, pH = 1.2;
          if (blinkNormalT > pN) blinkNormalT -= pN * Math.floor(blinkNormalT / pN);
          if (blinkHeavyT > pH) blinkHeavyT -= pH * Math.floor(blinkHeavyT / pH);
          blinkNormalVal = Math.exp(-Math.pow(5*blinkNormalT-2, 4));
          blinkHeavyVal = Math.exp(-Math.pow(5*blinkHeavyT-2, 4));
        }
        lastT = t;
        return dt;
      }

      function drawGridScaled(){
        if (!mapInfo || !mapInfo.gridSteps) return;
        const w = canvas.width, h = canvas.height;
        const minX = mapInfo.minX, maxX = mapInfo.maxX;
        const minY = mapInfo.minY, maxY = mapInfo.maxY;
        const gsx = mapInfo.gridSteps[0], gsy = mapInfo.gridSteps[1];
        const scX = (w * view.scale) / (maxX - minX);
        const scY = (h * view.scale) / (maxY - minY);
        const firstCellX = Math.floor((-view.offsetX / scX) / gsx);
        const firstCellY = Math.floor((-view.offsetY / scY) / gsy);
        const xVis0 = minX + firstCellX * gsx;
        const yVis0 = minY + firstCellY * gsy;
        const xVis1 = minX + Math.ceil((w - view.offsetX) / scX / gsx) * gsx;
        const yVis1 = minY + Math.ceil((h - view.offsetY) / scY / gsy) * gsy;
        ctx.lineWidth = 1; ctx.strokeStyle = '#555';
        ctx.beginPath();
        for (let y = yVis0; y <= yVis1; y += gsy) {
          const yy = Math.floor((y - minY) * scY + view.offsetY) + 0.5;
          ctx.moveTo(0, yy); ctx.lineTo(w, yy);
        }
        for (let x = xVis0; x <= xVis1; x += gsx) {
          const xx = Math.floor((x - minX) * scX + view.offsetX) + 0.5;
          ctx.moveTo(xx, 0); ctx.lineTo(xx, h);
        }
        ctx.stroke();
        // labels
        ctx.fillStyle = '#111'; ctx.font = 'normal 9pt sans-serif';
        ctx.textBaseline = 'middle'; ctx.textAlign = 'left';
        for (let y = yVis0 + gsy*0.5, n = firstCellY; y <= yVis1 && n < 26; y += gsy, ++n) {
          const yy = Math.floor((y - minY) * scY + view.offsetY) + 0.5;
          ctx.fillText(String.fromCharCode(65 + n), 3, yy);
        }
        ctx.textBaseline = 'top'; ctx.textAlign = 'center';
        for (let x = xVis0 + gsx*0.5, n = firstCellX; x <= xVis1; x += gsx, ++n) {
          const xx = Math.floor((x - minX) * scX + view.offsetX) + 0.5;
          ctx.fillText(n + 1, xx, 3);
        }
      }

      function drawPlayer(item){
        if (typeof item.x !== 'number' || typeof item.y !== 'number') return;
        const dx = (typeof item.dx === 'number') ? item.dx : 0;
        const dy = (typeof item.dy === 'number') ? item.dy : -1;
        // screen position in view coords (normalized x/y -> canvas px, then apply view)
        let sx = item.x * canvas.width;
        let sy = item.y * canvas.height;
        // y in telem normalized is usually already top-left; if it's bottom-left, flip if needed
        // assume already top-left normalized as in localhost.htm
        // center arrow
        const w = 7.0, l = 25.0;
        // apply view
        sx = sx * view.scale + view.offsetX;
        sy = sy * view.scale + view.offsetY;
        // compute base point centered
        const len = Math.hypot(dx, dy) || 1;
        const ndx = dx/len, ndy = dy/len;
        const cx = sx - l*0.5*ndx;
        const cy = sy - l*0.5*ndy;
        ctx.fillStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeStyle = '#333';
        ctx.beginPath();
        ctx.moveTo(cx - w*ndy, cy + w*ndx);
        ctx.lineTo(cx + w*ndy, cy - w*ndx);
        ctx.lineTo(cx + l*ndx, cy + l*ndy);
        ctx.closePath(); ctx.fill(); ctx.stroke();
      }

      function drawAirfield(item){
        const sx = canvas.width * (item.sx || 0);
        const sy = canvas.height * (item.sy || 0);
        const ex = canvas.width * (item.ex || 0);
        const ey = canvas.height * (item.ey || 0);
        const c = calcBlinkColor(item);
        ctx.lineWidth = 3.0 * Math.sqrt(view.scale);
        ctx.strokeStyle = c;
        ctx.beginPath();
        ctx.moveTo(sx * view.scale + view.offsetX, sy * view.scale + view.offsetY);
        ctx.lineTo(ex * view.scale + view.offsetX, ey * view.scale + view.offsetY);
        ctx.stroke();
      }

      function normalizeXY(o){
        // returns {x,y} normalized [0,1] or null if cannot compute
        if (typeof o.x === 'number' && typeof o.y === 'number' && o.x >= 0 && o.x <= 1 && o.y >= 0 && o.y <= 1) {
          return { x: o.x, y: o.y };
        }
        if (!mapInfo) return null;
        const ox = (typeof o.x === 'number') ? o.x : (o.pos && o.pos.x);
        const oy = (typeof o.y === 'number') ? o.y : (o.pos && o.pos.y);
        if (typeof ox === 'number' && typeof oy === 'number') {
          const px = (ox - mapInfo.minX) / (mapInfo.maxX - mapInfo.minX);
          const py = 1 - (oy - mapInfo.minY) / (mapInfo.maxY - mapInfo.minY);
          return { x: px, y: py };
        }
        return null;
      }

      function metaKey(o){
        return `${o.icon||''}|${o.type||''}|${o.team||''}`;
      }

      function correlateTracks(objs){
        const now = Date.now();
        // build candidates with normalized coords
        const cand = [];
        for (const o of objs) {
          const p = normalizeXY(o);
          if (!p) continue;
          o._nx = p.x; o._ny = p.y; // stash for draw
          o._meta = metaKey(o);
          cand.push(o);
        }
        // prepare unmatched sets
        const trackIds = Array.from(tracks.keys());
        const matchedTracks = new Set();
        const matchedObjs = new Set();

        // Group by meta to reduce cross-type confusion
        const byMetaTracks = new Map();
        const byMetaObjs = new Map();
        for (const tid of trackIds) {
          const tr = tracks.get(tid);
          if (!tr || !tr.points?.length) continue;
          const key = tr.meta || '';
          if (!byMetaTracks.has(key)) byMetaTracks.set(key, []);
          byMetaTracks.get(key).push(tid);
        }
        for (let i=0; i<cand.length; i++) {
          const m = cand[i]._meta || '';
          if (!byMetaObjs.has(m)) byMetaObjs.set(m, []);
          byMetaObjs.get(m).push(i);
        }

        const metas = new Set([...byMetaTracks.keys(), ...byMetaObjs.keys()]);
        const BIG = 1e6;
        for (const meta of metas) {
          const tids = byMetaTracks.get(meta) || [];
          const idxs = byMetaObjs.get(meta) || [];
          if (tids.length === 0 || idxs.length === 0) continue;
          // Build cost matrix
          const preds = tids.map(tid => ({ tid, pred: predictTrack(tracks.get(tid), now) }));
          const cost = preds.map(({ pred }) => idxs.map(i => {
            const o = cand[i];
            const d = Math.hypot(o._nx - pred.px, o._ny - pred.py);
            if (d > MATCH_MAX_DIST) return BIG;
            const dirPen = DIR_PENALTY_GAIN * dirPenalty(pred.vx, pred.vy, pred.last.x, pred.last.y, o._nx, o._ny);
            return d + dirPen;
          }));
          let assignment;
          if (USE_HUNGARIAN) assignment = hungarian(cost); else assignment = cost.map((row, r) => {
            // simple greedy per row if disabled (not optimal)
            let best = -1, bestVal = BIG;
            row.forEach((v, c) => { if (v < bestVal) { bestVal = v; best = c; } });
            return best;
          });
          // Apply assignment
          for (let r = 0; r < assignment.length; r++) {
            const c = assignment[r];
            if (c == null || c < 0 || c >= idxs.length) continue;
            const costVal = cost[r][c];
            if (!(costVal < BIG)) continue; // filtered by distance
            const tid = tids[r];
            const objIndex = idxs[c];
            if (matchedTracks.has(tid) || matchedObjs.has(objIndex)) continue;
            const tr = tracks.get(tid);
            const o = cand[objIndex];
            const last = tr.points[tr.points.length - 1];
            const move = Math.hypot(o._nx - last.x, o._ny - last.y);
            if (move > MOVEMENT_EPS) {
              tr.points.push({ x: o._nx, y: o._ny, t: now });
              if (tr.points.length > TRACK_MAX_POINTS) tr.points.splice(0, tr.points.length - TRACK_MAX_POINTS);
            }
            if (tr.points.length > TRACK_MAX_POINTS) tr.points.splice(0, tr.points.length - TRACK_MAX_POINTS);
            tr.lastSeen = now;
            o._tid = tid;
            matchedTracks.add(tid);
            matchedObjs.add(objIndex);
          }
        }

        // start new tracks for remaining objects (unmatched)
        for (let i = 0; i < cand.length; i++) {
          if (matchedObjs.has(i)) continue;
          const o = cand[i];
          const tid = String(nextTrackId++);
          const color = (typeof o.color === 'string') ? o.color : '#59a3ff';
          tracks.set(tid, { points: [{ x: o._nx, y: o._ny, t: now }], color, meta: o._meta, lastSeen: now });
          o._tid = tid;
        }
        // No time-based pruning; tracks persist until map generation changes
      }

      function drawTrail(o){
        const key = o._tid || null;
        const entry = key ? tracks.get(String(key)) : null;
        if (!entry || entry.points.length < 2) return;
        ctx.save();
        // faint color with alpha
        const col = entry.color || '#59a3ff';
        // convert hex to rgba with low alpha
        let r=89,g=163,b=255;
        const m = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(col);
        if (m) { r = parseInt(m[1],16); g = parseInt(m[2],16); b = parseInt(m[3],16); }
        ctx.strokeStyle = `rgba(${r},${g},${b},0.3)`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i=0; i<entry.points.length; i++) {
          const p = entry.points[i];
          const sx = p.x * canvas.width * view.scale + view.offsetX;
          const sy = p.y * canvas.height * view.scale + view.offsetY;
          if (i === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
        }
        ctx.stroke();
        ctx.restore();
      }

      function drawTrailEntry(entry){
        if (!entry || !Array.isArray(entry.points) || entry.points.length < 2) return;
        ctx.save();
        const col = entry.color || '#59a3ff';
        let r=89,g=163,b=255;
        const m = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(col);
        if (m) { r = parseInt(m[1],16); g = parseInt(m[2],16); b = parseInt(m[3],16); }
        ctx.strokeStyle = `rgba(${r},${g},${b},0.3)`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i=0; i<entry.points.length; i++) {
          const p = entry.points[i];
          const sx = p.x * canvas.width * view.scale + view.offsetX;
          const sy = p.y * canvas.height * view.scale + view.offsetY;
          if (i === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
        }
        ctx.stroke();
        ctx.restore();
      }

      function drawIcon(item){
        // Compute screen position
        const x = (item.x || 0) * canvas.width;
        const y = (item.y || 0) * canvas.height;
        const sx = x * view.scale + view.offsetX;
        const sy = y * view.scale + view.offsetY;

        // Try to draw image icon first
        const iconName = (typeof item.icon === 'string' && item.icon.trim()) ? item.icon.trim() : null;
        const img = iconName ? requestIcon(iconName) : null;
        const size = 18 * Math.sqrt(view.scale); // scale-aware icon size
        if (img && img.complete && img.naturalWidth > 0) {
          const hw = size * 0.5, hh = size * 0.5;
          try {
            ctx.save();
            ctx.drawImage(img, sx - hw, sy - hh, size, size);
            ctx.restore();
            return;
          } catch (_) { /* fall through to shapes */ }
        }

        // Geometric fallbacks
        const color = calcBlinkColor(item);
        ctx.fillStyle = color; ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
        const isRespawn = (item.type === 'respawn_base_fighter') || (item.type === 'respawn_base_bomber');
        if (item.type === 'capture_zone' || iconName === 'capture_zone') {
          // diamond fallback
          drawDiamond(sx, sy, 8 * Math.sqrt(view.scale), color, '#000');
          return;
        }
        if (iconName === 'LightTank') {
          // 1:4 flat rectangle fallback
          const h = 5 * Math.sqrt(view.scale);
          drawFlatRect(sx, sy, h, 4, color, '#000');
          return;
        }
        if (iconName === 'MediumTank') {
          // upside-down flat square U fallback (∩)
          const unit = 4 * Math.sqrt(view.scale);
          drawInvertedUSquare(sx, sy, unit, color, '#000');
          return;
        }
        if (iconName === 'SPAA') {
          // flat 1:4 bar with two 1x1 squares along the top
          const unit = 4 * Math.sqrt(view.scale);
          drawSPAA(sx, sy, unit, color, '#000');
          return;
        }
        if (iconName === 'HeavyTank') {
          // inverted U plus centered square on top
          const unit = 4 * Math.sqrt(view.scale);
          drawHeavyTankShape(sx, sy, unit, color, '#000');
          return;
        }
        if (isRespawn && typeof item.dx === 'number' && typeof item.dy === 'number') {
          // rotated triangle fallback for respawn bases
          const w = 5.0, l = 14.0; const len = Math.hypot(item.dx, item.dy) || 1;
          const ndx = item.dx/len, ndy = item.dy/len;
          const cx = sx - l*0.5*ndx; const cy = sy - l*0.5*ndy;
          ctx.beginPath();
          ctx.moveTo(cx - w*ndy, cy + w*ndx);
          ctx.lineTo(cx + w*ndy, cy - w*ndx);
          ctx.lineTo(cx + l*ndx, cy + l*ndy);
          ctx.closePath(); ctx.fill(); ctx.stroke();
          return;
        }
        // default: circle
        ctx.beginPath(); ctx.arc(sx, sy, 4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      }

      function render() {
        // update blink timers
        updateBlinkTimers();
        // clear
        ctx.save();
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.restore();

        // guard: no image yet
        if (!mapImg) { drawPlaceholder('Loading map...'); return; }

        // Draw map image with pan/zoom
        ctx.save();
        ctx.translate(view.offsetX, view.offsetY);
        ctx.scale(view.scale, view.scale);
        try {
          // draw image into canvas size to match normalized coords (0..1) from telemetry
          ctx.drawImage(mapImg, 0, 0, canvas.width, canvas.height);
        } catch (e) {}
        ctx.restore();

        // Draw all trails regardless of whether their objects are present
        try {
          tracks.forEach((entry) => {
            if (!entry || !Array.isArray(entry.points) || entry.points.length < 2) return;
            drawTrailEntry(entry);
          });
        } catch (_) {}

        // Grid overlay
        drawGridScaled();

        // Correlate and draw objects
        if (state.objects && state.objects.length) {
          // correlate tracks for current snapshot (handles missing persistent IDs)
          correlateTracks(state.objects);
          let player = null;
          for (const o of state.objects) {
            // use normalized coords prepared by correlateTracks
            if (typeof o._nx === 'number' && typeof o._ny === 'number') { o.x = o._nx; o.y = o._ny; }
            if (o && o.type === 'airfield') {
              drawAirfield(o);
            } else if (o && o.icon === 'Player') {
              player = o;
            } else {
              drawIcon(o);
            }
          }
          if (player) drawPlayer(player);
        }
      }

      // Touch state
      let touchStartDistance = 0;
      let initialScale = 1;
      let lastTouchTime = 0;
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartOffsetX = 0;
      let touchStartOffsetY = 0;

      // Touch start handler
      function handleTouchStart(e) {
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          const rect = canvas.getBoundingClientRect();
          touchStartX = touch.clientX - rect.left;
          touchStartY = touch.clientY - rect.top;
          touchStartOffsetX = view.offsetX;
          touchStartOffsetY = view.offsetY;
          
          // Handle double tap
          const currentTime = new Date().getTime();
          if (currentTime - lastTouchTime < 300) { // 300ms threshold for double tap
            // Reset view on double tap
            view.scale = 1;
            view.offsetX = 0;
            view.offsetY = 0;
            clampView();
            render();
          }
          lastTouchTime = currentTime;
        } else if (e.touches.length === 2) {
          // Store initial distance for pinch zoom
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          touchStartDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
          initialScale = view.scale;
        }
      }

      // Touch move handler
      function handleTouchMove(e) {
        e.preventDefault();
        
        if (e.touches.length === 1) {
          // Pan with one finger
          const touch = e.touches[0];
          const rect = canvas.getBoundingClientRect();
          const touchX = touch.clientX - rect.left;
          const touchY = touch.clientY - rect.top;
          
          view.offsetX = touchStartOffsetX + (touchX - touchStartX);
          view.offsetY = touchStartOffsetY + (touchY - touchStartY);
          clampView();
          render();
        } else if (e.touches.length === 2) {
          // Pinch zoom with two fingers
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
          
          if (touchStartDistance > 0) {
            const scale = initialScale * (currentDistance / touchStartDistance);
            view.scale = Math.max(0.1, Math.min(scale, 10)); // Limit zoom range
            clampView();
            render();
          }
        }
      }

      // Touch end handler
      function handleTouchEnd() {
        touchStartDistance = 0;
      }

      // Add touch event listeners
      canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
      canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
      canvas.addEventListener('touchend', handleTouchEnd);

      // Button event handlers
      document.getElementById('btnWin').addEventListener('click', () => recordResult('win'));
      document.getElementById('btnLoss').addEventListener('click', () => recordResult('loss'));
      
      const postBtn = document.getElementById('btnPostLogs');
      if (postBtn) postBtn.addEventListener('click', postLogs);
      
      const submitBtn = document.getElementById('btnSubmitJson');
      if (submitBtn) submitBtn.addEventListener('click', submitJson);
      
      const resetBtn = document.getElementById('btnReset');
      if (resetBtn) {
        resetBtn.addEventListener('click', function() {
          const ok = window.confirm('Are you sure you want to reset? This will clear entries and reset the game counter.');
          if (ok) resetState();
        });
      }

      // Interaction: drag to pan (mouse)
canvas.addEventListener('mousedown', (e) => {
  if (measuring) return;
  dragging = true;
  const rect = canvas.getBoundingClientRect();
  dragStart.x = e.clientX - rect.left;
  dragStart.y = e.clientY - rect.top;
  startOffset.x = view.offsetX; startOffset.y = view.offsetY;
});
window.addEventListener('mousemove', (e) => {
  if (!dragging) return;
  const rect = canvas.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;
  view.offsetX = startOffset.x + (cx - dragStart.x);
  view.offsetY = startOffset.y + (cy - dragStart.y);
  clampView();
  render();
});
window.addEventListener('mouseup', () => { dragging = false; });

// Wheel to zoom (zoom to cursor)
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const delta = -Math.sign(e.deltaY) * 0.2;
  const oldScale = view.scale;
  let newScale = Math.min(limits.maxScale, Math.max(limits.minScale, oldScale * (1 + delta)));
  const rect = canvas.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;
  // Compute world point under cursor before zoom
  const wx = (cx - view.offsetX) / oldScale;
  const wy = (cy - view.offsetY) / oldScale;
  view.scale = newScale;
  // Keep point under cursor stationary
  view.offsetX = cx - wx * newScale;
  view.offsetY = cy - wy * newScale;
  clampView();
  render();
}, { passive: false });

// Controls
document.getElementById('btnZoomIn').addEventListener('click', () => {
  const evt = new WheelEvent('wheel', { deltaY: -100, bubbles: true });
  canvas.dispatchEvent(evt);
});
document.getElementById('btnZoomOut').addEventListener('click', () => {
  const evt = new WheelEvent('wheel', { deltaY: 100, bubbles: true });
  canvas.dispatchEvent(evt);
});
document.getElementById('btnReset').addEventListener('click', () => {
  view.scale = 1; view.offsetX = 0; view.offsetY = 0; clampView(); render();
});

function startAuto() {
  if (timer) return;
  timer = setInterval(() => { loadMapImageOnce(); refreshInfo(); }, 1000);
  if (!objTimer) objTimer = setInterval(refreshObjects, 1000);
}
function stopAuto() {
  if (timer) { clearInterval(timer); timer = null; }
  if (!objTimer) { clearInterval(objTimer); objTimer = null; }
}

// Periodically persist tracks (every 15s)
let persistTimer = null;
function startPersist() {
  if (persistTimer) return;
  persistTimer = setInterval(postTracks, 15000);
}
function stopPersist() {
  if (persistTimer) { clearInterval(persistTimer); persistTimer = null; }
}

// --- Right column: minimal data fetch/render ---
// Adopt filtering controls like index.html but scoped to right column
let rowsR = [];
let statusFilterR = 'all';
function normalizeTypeR(cls){
  if (!cls) return 'other';
  const c = String(cls).toLowerCase();
  if (c === 'light tank') return 'light tank';
  if (c === 'medium tank') return 'medium tank';
  if (c === 'heavy tank') return 'heavy tank';
  if (c === 'tank destroyer') return 'spg';
  if (c === 'spaa') return 'spaa';
  if (c === 'fighter') return 'fighter';
  if (c === 'attacker') return 'attacker';
  if (c === 'bomber') return 'bomber';
  if (c === 'helicopter') return 'helicopter';
  return 'other';
}
async function fetchGamesR(){
  const [gamesResp, currentResp] = await Promise.all([
    fetch('/api/games-list'), fetch('/api/current-game')
  ]);
  const games = await gamesResp.json();
  const current = (await currentResp.json()).currentGame;
  return { games, current };
}
async function fetchRowsForGameR(game){
  if (game === 'all') {
    const gl = await (await fetch('/api/games-list')).json();
    const results = await Promise.all(gl.map(g => fetch('/api/active-vehicles?game=' + encodeURIComponent(g)).then(r=>r.json()).then(list => list.map(it => { if (it && (it.game==null)) it.game = g; return it; }))));
    rowsR = [].concat.apply([], results);
  } else {
    if (game === 'current') {
      try { const j = await (await fetch('/api/current-game')).json(); game = String(j.currentGame); } catch (_) {}
    }
    const resp = await fetch('/api/active-vehicles?game=' + encodeURIComponent(game));
    rowsR = await resp.json();
    rowsR = rowsR.map(it => { if (it && (it.game==null)) it.game = game; return it; });
  }
}
function populateFilterR(selectId, values, placeholder){
  const sel = document.getElementById(selectId);
  const prev = sel.value;
  sel.innerHTML = '';
  const allOpt = document.createElement('option');
  allOpt.value = 'all'; allOpt.textContent = placeholder; sel.appendChild(allOpt);
  values.forEach(v => { const opt = document.createElement('option'); opt.value = v; opt.textContent = v; sel.appendChild(opt); });
  if (values.includes(prev)) sel.value = prev; else sel.value = 'all';
}
function renderCurrentGameTableR(list){
  const tbody = document.getElementById('curGameTableBody');
  if (!tbody) return;
  if (!Array.isArray(list) || list.length === 0) { 
    tbody.innerHTML = '<tr><td colspan="5" style="color:#888;">No data</td></tr>'; 
    return; 
  }
  
  tbody.innerHTML = list.map(r => {
    const statusClass = (r.status === 'destroyed') ? 'status-destroyed' : 'status-active';
    const statusText = (r.status === 'destroyed') ? 'dead' : 'alive';
    
    // Get highlight colors - player highlight overrides squadron highlight
    let hl = getColorPair(highlights.players[r.player]);
    if (!hl.bg && !hl.fg) {
      hl = getColorPair(highlights.squadrons[r.squadron]);
    }
    
    // Build style string
    const styles = [];
    if (hl.bg) styles.push(`background-color: ${hl.bg}`);
    if (hl.fg) styles.push(`color: ${hl.fg}`);
    const styleAttr = styles.length ? ` style="${styles.join('; ')};"` : '';
    
    return '<tr' + styleAttr + '>' +
      '<td>' + (r.squadron ?? '') + '</td>' +
      '<td>' + (r.player ?? '') + '</td>' +
      '<td>' + (r.vehicle ?? '') + '</td>' +
      '<td class="' + statusClass + '">' + statusText + '</td>' +
      '<td>' + (r.kills ?? 0) + '</td>' +
    '</tr>';
  }).join('');
}
function applyFiltersAndRenderR(){
  const squadron = document.getElementById('filterSquadronR').value;
  const player = document.getElementById('filterPlayerR').value;
  const vehicle = document.getElementById('filterVehicleR').value;
  const filtered = rowsR.filter(r => (
    (squadron === 'all' || r.squadron === squadron) &&
    (player === 'all' || r.player === player) &&
    (vehicle === 'all' || r.vehicle === vehicle) &&
    (statusFilterR === 'all' || r.status === statusFilterR)
  ));
  // update dependent filters from rowsR
  populateFilterR('filterSquadronR', Array.from(new Set(rowsR.map(r=>r.squadron))).sort(), 'All Squadrons');
  populateFilterR('filterPlayerR', Array.from(new Set(rowsR.map(r=>r.player))).sort(), 'All Players');
  populateFilterR('filterVehicleR', Array.from(new Set(rowsR.map(r=>r.vehicle))).sort(), 'All Vehicles');
  renderCurrentGameTableR(filtered);
}
async function initRightControls(){
  const { games, current } = await fetchGamesR();
  await fetchHighlights(); // Load highlight colors
  const sel = document.getElementById('filterGameR');
  const saved = localStorage.getItem('selectedGameR');
  const initial = (saved === 'all' || saved === 'current') ? saved : (saved && games.includes(parseInt(saved,10)) ? saved : 'current');
  sel.innerHTML = '<option value="current">Current Game</option><option value="all">All Games</option>' + games.map(g => '<option value="'+g+'">Game '+g+'</option>').join('');
  sel.value = initial;
  localStorage.setItem('selectedGameR', sel.value);
  await fetchRowsForGameR(sel.value);
  applyFiltersAndRenderR();
  // wire events
  ['filterGameR','filterSquadronR','filterPlayerR','filterVehicleR'].forEach(id => {
    document.getElementById(id).addEventListener('change', async (e) => {
      if (id === 'filterGameR') {
        localStorage.setItem('selectedGameR', e.target.value);
        await fetchRowsForGameR(e.target.value);
      }
      applyFiltersAndRenderR();
    });
  });
  // prev/next
  const prevBtn = document.getElementById('btnPrevGameR');
  const nextBtn = document.getElementById('btnNextGameR');
  prevBtn.addEventListener('click', async () => {
    const sorted = games.slice().sort((a,b)=>a-b);
    let curVal = sel.value === 'current' ? String(current) : (sel.value === 'all' ? String(current) : sel.value);
    let idx = sorted.findIndex(g => String(g) === String(curVal)); if (idx < 0) idx = 0; const nextIdx = Math.max(0, idx - 1);
    sel.value = String(sorted[nextIdx]); localStorage.setItem('selectedGameR', sel.value);
    await fetchRowsForGameR(sel.value); applyFiltersAndRenderR();
  });
  nextBtn.addEventListener('click', async () => {
    const sorted = games.slice().sort((a,b)=>a-b);
    let curVal = sel.value === 'current' ? String(current) : (sel.value === 'all' ? String(current) : sel.value);
    let idx = sorted.findIndex(g => String(g) === String(curVal)); if (idx < 0) idx = 0; const nextIdx = Math.min(sorted.length - 1, idx + 1);
    sel.value = String(sorted[nextIdx]); localStorage.setItem('selectedGameR', sel.value);
    await fetchRowsForGameR(sel.value); applyFiltersAndRenderR();
  });
  // status buttons
  const bAlive = document.getElementById('btnStatusAliveR');
  const bDestroyed = document.getElementById('btnStatusDestroyedR');
  
  function toggleStatusFilter(clickedStatus) {
    // If clicking the same status that's already active, reset to 'all'
    statusFilterR = statusFilterR === clickedStatus ? 'all' : clickedStatus;
    localStorage.setItem('statusFilterR', statusFilterR);
    updateStatusButtons();
    applyFiltersAndRenderR();
  }
  
  function updateStatusButtons() {
    bAlive.classList.toggle('selected', statusFilterR === 'active');
    bDestroyed.classList.toggle('selected', statusFilterR === 'destroyed');
  }
  
  // Set up event listeners
  bAlive.addEventListener('click', () => toggleStatusFilter('active'));
  bDestroyed.addEventListener('click', () => toggleStatusFilter('destroyed'));
  
  // Initialize status filter
  try { 
    const savedS = localStorage.getItem('statusFilterR'); 
    statusFilterR = (savedS === 'active' || savedS === 'destroyed' || savedS === 'all') ? savedS : 'all'; 
  } catch (_) { 
    statusFilterR = 'all'; 
  }
  updateStatusButtons();
}

async function refreshRightAllGamesSummary(){
  const tgt = document.getElementById('rightAllGamesSummaryBody');
  if (!tgt) return;
  try {
    const resp = await fetch('/api/merged-summary');
    const j = await resp.json();
    const lines = (j && Array.isArray(j.lines)) ? j.lines : [];
    tgt.innerHTML = (lines && lines.length) ? lines.map(l => '<tr><td>' + l + '</td></tr>').join('') : '<tr><td>No data</td></tr>';
  } catch (_) {
    tgt.innerHTML = '<tr><td>No data</td></tr>';
  }
}


    // Helper functions for button actions
async function recordResult(kind) {
  try {
    const response = await fetch(`/api/record-${kind}`, { method: 'POST' });
    const result = await response.json();
    if (!result.success) {
      console.error(`Failed to record ${kind}:`, result.message || 'Unknown error');
    }
    // Refresh both the main info and the summary table
    await Promise.all([
      refreshInfo(),
      refreshRightAllGamesSummary()
    ]);
  } catch (e) {
    console.error(`Error recording ${kind}:`, e);
  }
}

async function postLogs() {
  try {
    const response = await fetch('/api/post-logs', { method: 'POST' });
    const result = await response.json();
    if (result.success) {
      alert('Logs posted successfully!');
    } else {
      alert(`Failed to post logs: ${result.message || 'Unknown error'}`);
    }
  } catch (e) {
    console.error('Error posting logs:', e);
    alert(`Error posting logs: ${e.message}`);
  }
}

async function submitJson() {
  try {
    const ok = window.confirm('Submit current parsed JSON to backend?');
    if (!ok) return;
    
    const response = await fetch('/api/submit-json', { method: 'POST' });
    const result = await response.json();
    
    if (result.success) {
      alert('JSON submitted successfully!');
    } else {
      alert(`Failed to submit JSON: ${result.message || 'Unknown error'}`);
    }
  } catch (e) {
    console.error('Error submitting JSON:', e);
    alert(`Error submitting JSON: ${e.message}`);
  }
}

async function resetState() {
  try {
    const response = await fetch('/api/reset', { method: 'POST' });
    const result = await response.json();
    
    if (result.success) {
      alert('State reset successfully!');
      refreshInfo();
    } else {
      alert(`Failed to reset state: ${result.message || 'Unknown error'}`);
    }
  } catch (e) {
    console.error('Error resetting state:', e);
    alert(`Error resetting state: ${e.message}`);
  }
}

    })();

      </script>
      <script>
        const measureButton = document.getElementById('btnMeasure');
        let measuring = false;
        let points = [];

        measureButton.addEventListener('click', () => {
          measuring = !measuring;
          if (measuring) {
            measureButton.classList.add('selected');
            canvas.style.cursor = 'crosshair';
          } else {
            measureButton.classList.remove('selected');
            canvas.style.cursor = 'default';
            points = [];
            render();
          }
        });

        canvas.addEventListener('click', (e) => {
          if (!measuring) return;

          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          points.push({ x, y });

          if (points.length === 1) {
            render();
            drawMarker(points[0]);
          } else if (points.length === 2) {
            render();
            drawLine(points[0], points[1]);
            calculateAndDisplayDistance(points[0], points[1]);
            measuring = false;
            measureButton.classList.remove('selected');
            canvas.style.cursor = 'default';
            points = [];
          }
        });

        function drawMarker(point) {
          ctx.save();
          ctx.fillStyle = 'red';
          ctx.beginPath();
          ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
          ctx.fill();
          ctx.restore();
        }

        function drawLine(p1, p2) {
          ctx.save();
          ctx.strokeStyle = 'red';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
          ctx.restore();
        }

        function calculateAndDisplayDistance(p1, p2) {
          if (!mapInfo) return;

          const pixelDist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
          
          const mapWidth = mapInfo.maxX - mapInfo.minX;
          const mapHeight = mapInfo.maxY - mapInfo.minY;

          const realDistX = (pixelDist / canvas.width) * mapWidth;
          const realDistY = (pixelDist / canvas.height) * mapHeight;

          const ingameDist = Math.hypot(realDistX, realDistY) / 1000; // Assuming grid scale is in meters

          ctx.save();
          ctx.fillStyle = 'white';
          ctx.font = 'bold 16px sans-serif';
          ctx.fillText(`${ingameDist.toFixed(2)} km`, p2.x + 10, p2.y - 10);
          ctx.restore();
        }

      </script>
</body>
</html>
