<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>War Thunder Parsed Data</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png">
  <link rel="shortcut icon" href="/favicon.ico">
  <style>
    body { font-family: Arial, sans-serif; background: #121212; color: #e0e0e0; margin: 0; }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
    h1 { color: #4CAF50; margin: 0 0 12px 0; }
    .topnav { margin: 6px 0 16px 0; }
    .topnav a { color: #90CAF9; text-decoration: none; margin-left: 10px; }
    .topnav {
      display: flex; align-items: center; gap: 8px; flex-wrap: wrap;
    }
    .meta-input { background: #1e1e1e; color: #ddd; border: 1px solid #444; padding: 4px 6px; border-radius: 4px; width: 110px; }
    .btn { background: #2a2a2a; color: #ddd; border: 1px solid #444; padding: 6px 10px; border-radius: 4px; cursor: pointer; }
    .btn:hover { background: #333; }
    .btn-win { background: #2e7d32; border-color: #1b5e20; color: #e8f5e9; }
    .btn-win:hover { background: #1b5e20; }
    .btn-loss { background: #c62828; border-color: #8e0000; color: #ffebee; }
    .btn-loss:hover { background: #8e0000; }
    .filters { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px; }
    select { background: #1e1e1e; color: #ddd; border: 1px solid #444; padding: 6px 8px; border-radius: 4px; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 18px; }
    thead th { background: #1e1e1e; color: #aaa; padding: 8px; border-bottom: 1px solid #333; text-align: left; }
    tbody td { padding: 6px 8px; border-bottom: 1px solid #2a2a2a; }
    .status-active { color: #66BB6A; }
    .status-destroyed { color: #EF5350; }
    .section-title { margin: 16px 0 8px 0; color: #90CAF9; }
    /* Monospace summary table to preserve alignment */
    .mono-table { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .mono-table td { white-space: pre; }
    /* Collapsible sections */
    .section-title { display: flex; align-items: center; gap: 8px; }
    .toggle-btn { background: #1e1e1e; color: #bbb; border: 1px solid #444; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; }
    .toggle-btn:hover { background: #2a2a2a; color: #fff; }
    .collapsed { display: none !important; }
    .game-switcher { display: flex; align-items: center; gap: 6px; }
    .status-switcher { display: flex; align-items: center; gap: 6px; }
    .btn-alive { background: #2e7d32; border-color: #1b5e20; color: #e8f5e9; }
    .btn-alive:hover { background: #1b5e20; }
    .btn-destroyed { background: #c62828; border-color: #8e0000; color: #ffebee; }
    .btn-destroyed:hover { background: #8e0000; }
    .btn-neutral { background: #3a3a3a; border-color: #555; color: #ddd; }
    .btn-neutral:hover { background: #2f2f2f; }
    .btn.selected { outline: 2px solid #90CAF9; }
  </style>
  <script>
    let rows = [];
    let summaries = [];
    let allSummaries = [];
    let mergedSummary = { meta: { squadNo: '', ac: '', gc: '' }, lines: [] };
    let resultsMap = {};
    let highlights = { players: {}, squadrons: {} };
    const ws = new WebSocket('ws://localhost:3001');
    let gameMeta = { squadNo: '', gc: '', ac: '', game: null };
    const OUTPUT_ORDER = ['Medium','Heavy','Light','SPG','Fighter','Attacker','Bomber','Heli','SPAA'];
    let statusFilter = 'all';

    async function fetchGames() {
      const [gamesResp, currentResp] = await Promise.all([
        fetch('/api/games-list'),
        fetch('/api/current-game')
      ]);
      const games = await gamesResp.json();
      const current = (await currentResp.json()).currentGame;
      return { games, current };
    }

    // Change selected game by +/- 1 within available list
    async function changeGameBy(delta) {
      try {
        const gameSel = document.getElementById('filterGame');
        const { games, current } = await fetchGames();
        if (!Array.isArray(games) || games.length === 0) return;
        const sorted = games.slice().sort((a,b) => a-b);
        let curVal = gameSel.value;
        let curNum;
        if (curVal === 'current') curNum = Number(current);
        else if (curVal === 'all') curNum = Number(current);
        else curNum = Number(curVal);
        if (!Number.isFinite(curNum)) curNum = Number(current);
        let idx = sorted.findIndex(g => Number(g) === curNum);
        if (idx < 0) idx = 0;
        let nextIdx = Math.min(sorted.length - 1, Math.max(0, idx + (delta || 0)));
        const nextGame = String(sorted[nextIdx]);
        // Update selector and persist
        gameSel.value = nextGame;
        localStorage.setItem('selectedGame', nextGame);
        // Refresh data
        await fetchRowsForSelectedGame();
        await fetchSummariesForSelectedGame();
        await fetchAllSummaries();
        await fetchMetaForSelectedGame();
        await fetchResults();
        await fetchMergedSummary();
        applyFiltersAndRender();
      } catch (_) {}
    }

    async function fetchMetaForSelectedGame() {
      const gameSel = document.getElementById('filterGame');
      let game = gameSel.value;
      if (game === 'current') {
        try { game = String((await (await fetch('/api/current-game')).json()).currentGame); } catch (_) {}
      }
      try {
        const res = await fetch('/api/meta' + (game && game !== 'all' ? ('?game=' + encodeURIComponent(game)) : ''));
        const j = await res.json();
        gameMeta = { game: j.game, ...(j.meta || { squadNo: '', gc: '', ac: '' }) };
      } catch (_) { gameMeta = { squadNo: '', gc: '', ac: '', game: game }; }
      // reflect into inputs
      const iSquad = document.getElementById('inpSquadNo');
      const iGc = document.getElementById('inpGC');
      const iAc = document.getElementById('inpAC');
      if (iSquad) iSquad.value = gameMeta.squadNo || '';
      if (iGc) iGc.value = gameMeta.gc || '';
      if (iAc) iAc.value = gameMeta.ac || '';
    }

    async function saveMetaForSelectedGame() {
      let game = document.getElementById('filterGame').value;
      if (game === 'current' || game === 'all') {
        try { game = String((await (await fetch('/api/current-game')).json()).currentGame); } catch (_) {}
      }
      const payload = {
        squadNo: document.getElementById('inpSquadNo').value || '',
        gc: document.getElementById('inpGC').value || '',
        ac: document.getElementById('inpAC').value || ''
      };
      try {
        await fetch('/api/meta?game=' + encodeURIComponent(game), { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        await fetchMetaForSelectedGame();
        await fetchSummariesForSelectedGame();
        applyFiltersAndRender();
      } catch (_) {}
    }

    // Load highlight colors for players and squadrons
    async function fetchHighlights() {
      try {
        const resp = await fetch('/api/highlights');
        const data = await resp.json();
        if (data && typeof data === 'object') {
          highlights = {
            players: data.players || {},
            squadrons: data.squadrons || {}
          };
        }
      } catch (_) { /* keep defaults */ }
    }

    function getColorPair(entry) {
      // Accept either string (treated as background) or object { bg, fg }
      if (!entry) return { bg: '', fg: '' };
      if (typeof entry === 'string') return { bg: entry, fg: '' };
      const bg = (entry.bg || '').trim();
      const fg = (entry.fg || '').trim();
      return { bg, fg };
    }

    // Map stored classification (Title Case, e.g. "Light Tank", "Tank destroyer")
    // to filter option value (lowercase: 'light tank', 'spg', etc.)
    function normalizeType(cls) {
      if (!cls) return 'other';
      const c = String(cls).toLowerCase();
      if (c === 'light tank') return 'light tank';
      if (c === 'medium tank') return 'medium tank';
      if (c === 'heavy tank') return 'heavy tank';
      if (c === 'tank destroyer') return 'spg';
      if (c === 'spaa') return 'spaa';
      if (c === 'fighter') return 'fighter';
      if (c === 'attacker') return 'attacker';
      if (c === 'bomber') return 'bomber';
      if (c === 'helicopter') return 'helicopter';
      return 'other';
    }

    async function fetchRowsForSelectedGame() {
      const gameSel = document.getElementById('filterGame');
      let game = gameSel.value;
      if (game === 'current') {
        try {
          const current = (await (await fetch('/api/current-game')).json()).currentGame;
          game = String(current);
        } catch (_) { /* ignore */ }
      }
      if (game === 'all') {
        // Fetch all games and aggregate
        const gamesResp = await fetch('/api/games-list');
        const games = await gamesResp.json();
        const promises = games.map(function(g){
          return fetch('/api/active-vehicles?game=' + encodeURIComponent(g))
            .then(function(r){ return r.json(); })
            .then(function(list){
              return list.map(function(item){
                if (item && (item.game === undefined || item.game === null)) {
                  item.game = g; // ensure game column present
                }
                return item;
              });
            });
        });
        const results = await Promise.all(promises);
        rows = [].concat.apply([], results);
      } else {
        // Fetch only the selected game
        const resp = await fetch('/api/active-vehicles?game=' + encodeURIComponent(game));
        rows = await resp.json();
        // ensure game column present for display
        rows = rows.map(function(item){
          if (item && (item.game === undefined || item.game === null)) {
            item.game = (isNaN(parseInt(game, 10)) ? game : parseInt(game, 10));
          }
          return item;
        });
      }
      // Setup collapsible sections after initial render
      setupCollapsibles();
    }

    // Add collapse/expand buttons to each section title and persist state
    function setupCollapsibles() {
      const headers = document.querySelectorAll('h2.section-title');
      headers.forEach((h2, idx) => {
        if (h2.querySelector('.toggle-btn')) return; // already wired
        const key = 'collapse:' + (h2.textContent || ('section-' + idx)).trim().toLowerCase();
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'toggle-btn';
        // Collect all sibling elements until the next section-title header
        const group = [];
        let node = h2.nextElementSibling;
        while (node && !(node.tagName === 'H2' && node.classList.contains('section-title'))) {
          group.push(node);
          node = node.nextElementSibling;
        }
        const collapsed = localStorage.getItem(key) === '1';
        if (collapsed) group.forEach(el => el.classList.add('collapsed'));
        btn.textContent = collapsed ? 'Show' : 'Hide';
        btn.addEventListener('click', () => {
          if (group.length === 0) return;
          const willHide = !group[0].classList.contains('collapsed');
          group.forEach(el => el.classList.toggle('collapsed', willHide));
          btn.textContent = willHide ? 'Show' : 'Hide';
          localStorage.setItem(key, willHide ? '1' : '0');
        });
        h2.prepend(btn);
      });
    }

    async function fetchSummariesForSelectedGame() {
      const gameSel = document.getElementById('filterGame');
      let game = gameSel.value;
      if (game === 'current') {
        const resp = await fetch('/api/current-game');
        const j = await resp.json();
        game = j.currentGame;
      } else if (game === 'all') {
        // keep as 'all' for summaries call
      }
      const params = new URLSearchParams();
      if (game !== 'all') params.set('game', game);
      const res = await fetch('/api/summaries' + (params.toString() ? ('?' + params.toString()) : ''));
      summaries = await res.json();
      // Refresh meta too to keep render in sync
      await fetchMetaForSelectedGame();
    }

    async function fetchAllSummaries() {
      try {
        const resp = await fetch('/api/summaries');
        allSummaries = await resp.json();
      } catch (e) { allSummaries = []; }
    }

    async function fetchResults() {
      try {
        const resp = await fetch('/api/results');
        resultsMap = await resp.json();
      } catch (e) { resultsMap = {}; }
    }

    async function fetchMergedSummary() {
      try {
        const resp = await fetch('/api/merged-summary');
        mergedSummary = await resp.json();
      } catch (e) { mergedSummary = { meta: { squadNo: '', ac: '', gc: '' }, lines: [] }; }
    }

    // Record a manual result for the selected (or current) game
    async function recordResult(kind) {
      try {
        let game = document.getElementById('filterGame').value;
        if (game === 'all' || game === 'current') {
          const j = await (await fetch('/api/current-game')).json();
          game = String(j.currentGame);
        }
        const url = '/api/result?type=' + encodeURIComponent(kind) + '&game=' + encodeURIComponent(game);
        const resp = await fetch(url, { method: 'POST' });
        const data = await resp.json();
        if (resp.ok) {
          // Refresh data views
          await fetchRowsForSelectedGame();
          await fetchSummariesForSelectedGame();
          await fetchAllSummaries();
          await fetchResults();
          await fetchMergedSummary();
          applyFiltersAndRender();
        } else {
          console.error('Failed to record result:', data && data.error);
        }
      } catch (e) {
        console.error('Error recording result:', e);
      }
    }

    function populateFilter(selectId, values, placeholder) {
      const sel = document.getElementById(selectId);
      const prev = sel.value;
      sel.innerHTML = '';
      const allOpt = document.createElement('option');
      allOpt.value = 'all';
      allOpt.textContent = placeholder;
      sel.appendChild(allOpt);
      values.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v;
        opt.textContent = v;
        sel.appendChild(opt);
      });
      if (values.includes(prev)) sel.value = prev; else sel.value = 'all';
    }

    function applyFiltersAndRender() {
      const game = document.getElementById('filterGame').value;
      const squadron = document.getElementById('filterSquadron').value;
      const player = document.getElementById('filterPlayer').value;
      const vehicle = document.getElementById('filterVehicle').value;
      const status = statusFilter;
      const type = document.getElementById('filterType').value;

      const filtered = rows.filter(r => (
        (squadron === 'all' || r.squadron === squadron) &&
        (player === 'all' || r.player === player) &&
        (vehicle === 'all' || r.vehicle === vehicle) &&
        (status === 'all' || r.status === status) &&
        (type === 'all' || normalizeType(r.classification) === type)
      ));

      // Update dependent filters from filtered dataset
      const squadrons = Array.from(new Set(rows.map(r => r.squadron))).sort();
      const players = Array.from(new Set(rows.map(r => r.player))).sort();
      const vehicles = Array.from(new Set(rows.map(r => r.vehicle))).sort();
      populateFilter('filterSquadron', squadrons, 'All Squadrons');
      populateFilter('filterPlayer', players, 'All Players');
      populateFilter('filterVehicle', vehicles, 'All Vehicles');

      const tbody = document.getElementById('tableBody');
      tbody.innerHTML = filtered.map(function(r) {
        var statusClass = (r.status === 'destroyed') ? 'status-destroyed' : 'status-active';
        // Player highlight overrides squadron highlight
        var hl = getColorPair(highlights.players[r.player]) ;
        if (!hl.bg && !hl.fg) hl = getColorPair(highlights.squadrons[r.squadron]);
        var styles = [];
        if (hl.bg) styles.push('background-color: ' + hl.bg + ';');
        if (hl.fg) styles.push('color: ' + hl.fg + ';');
        var rowStyle = styles.length ? (' style="' + styles.join(' ') + '"') : '';
        return '<tr' + rowStyle + '>' +
          '<td>' + r.game + '</td>' +
          '<td>' + r.squadron + '</td>' +
          '<td>' + r.player + '</td>' +
          '<td>' + r.vehicle + '</td>' +
          '<td>' + (r.classification || 'other') + '</td>' +
          '<td class="' + statusClass + '">' + r.status + '</td>' +
          '<td>' + (r.kills || 0) + '</td>' +
        '</tr>';
      }).join('');

      // Render summaries below
      const selGame = document.getElementById('filterGame').value;
      const summaryTbody = document.getElementById('summaryBody');
      // If 'all' or 'current' is selected, summaries already contain the correct scope
      // (fetchSummariesForSelectedGame() requested the appropriate dataset),
      // so do not re-filter by the literal 'current' value.
      const view = (selGame === 'all' || selGame === 'current')
        ? summaries
        : summaries.filter(function(s){ return String(s.game) === String(selGame); });
      // group by game then sort by squadron already pre-sorted
      let html = '';
      let lastGame = null;
      view.forEach(function(s){
        var hl = getColorPair(highlights.squadrons[s.squadron]);
        var styles = [];
        if (hl.bg) styles.push('background-color: ' + hl.bg + ';');
        if (hl.fg) styles.push('color: ' + hl.fg + ';');
        var cellStyle = styles.length ? (' style="' + styles.join(' ') + '"') : '';
        if (lastGame !== s.game) {
          html += '<tr><td><strong>Game ' + s.game + '</strong></td></tr>';
          // Insert per-game meta immediately after the Game header (for selected game views)
          if (selGame !== 'all' && String(s.game) === String((gameMeta && gameMeta.game) || s.game)) {
            const meta = gameMeta || { squadNo: '', gc: '', ac: '' };
            html += '<tr><td><strong>Squad:</strong> ' + (meta.squadNo || '') + '</td></tr>';
            html += '<tr><td><strong>GC:</strong> ' + (meta.gc || '') + '</td></tr>';
            html += '<tr><td><strong>AC:</strong> ' + (meta.ac || '') + '</td></tr>';
          }
          lastGame = s.game;
        }
        // Render a single preformatted line (already padded so first | is column 7)
        html += '<tr><td' + cellStyle + '>' + s.line + '</td></tr>';
      });
      summaryTbody.innerHTML = html || '<tr><td>No data</td></tr>';

      // Render merged summary per game (one line per game)
      try {
        const tgt = document.getElementById('allGamesSummaryBody');
        if (tgt) {
          const isExcluded = (sqName) => {
            try {
              const h = highlights.squadrons[sqName];
              if (h && typeof h === 'object' && h.exclude === true) return true;
            } catch (_) {}
            return false;
          };
          // Render from shared formatter output
          let mergedHtml = '';
          try {
            const meta = mergedSummary && mergedSummary.meta ? mergedSummary.meta : { squadNo: '', gc: '', ac: '' };
            mergedHtml += `<tr><td>Squad: ${meta.squadNo || ''}</td></tr>`;
            mergedHtml += `<tr><td>AC: ${meta.ac || ''}</td></tr>`;
            mergedHtml += `<tr><td>GC: ${meta.gc || ''}</td></tr>`;
          } catch (_) {}
          let lines = (mergedSummary && Array.isArray(mergedSummary.lines)) ? mergedSummary.lines : [];
          if (!lines || lines.length === 0) {
            // Fallback: build client-side from allSummaries + resultsMap (legacy logic)
            const grouped = new Map(); // game -> { totals, squads }
            (allSummaries || []).forEach(item => {
              if (!item || !item.counts || item.game == null) return;
              const game = Number(item.game);
              const sq = item.squadron;
              if (!sq || isExcluded(sq)) return;
              if (!grouped.has(game)) {
                const totals = {}; OUTPUT_ORDER.forEach(k => totals[k] = 0);
                grouped.set(game, { totals, squads: new Set() });
              }
              const g = grouped.get(game);
              g.squads.add(sq);
              OUTPUT_ORDER.forEach(label => { g.totals[label] = (g.totals[label] || 0) + (item.counts[label] || 0); });
            });
            let winTotal = 0, lossTotal = 0;
            try {
              Object.keys(resultsMap || {}).forEach(k => { if (resultsMap[k] === true) winTotal++; else if (resultsMap[k] === false) lossTotal++; });
            } catch (_) {}
            const games = Array.from(grouped.keys()).sort((a,b) => a - b);
            lines = games.map(gm => {
              const g = grouped.get(gm);
              const sqName = (g.squads.size <= 1) ? (Array.from(g.squads)[0] || '') : 'MULT.';
              const parts = OUTPUT_ORDER.map(label => `${g.totals[label] || 0} ${label}`);
              const namePad = String(sqName).replace(/[^A-Za-z0-9]/g,'').padEnd(6,' ').slice(0,6);
              const indicator = (String(resultsMap[String(gm)]) === 'true' || resultsMap[String(gm)] === true) ? 'W' : ((String(resultsMap[String(gm)]) === 'false' || resultsMap[String(gm)] === false) ? 'L' : '');
              return `${namePad} | ${parts.join(' | ')} | ${indicator ? (indicator + ' | ') : ''}${winTotal}:${lossTotal} |`;
            });
          }
          tgt.innerHTML = (lines && lines.length) ? lines.map(l => `<tr><td>${l}</td></tr>`).join('') : '<tr><td>No data</td></tr>';
        }
      } catch (_) {}
    }

    async function init() {
      const { games, current } = await fetchGames();
      await fetchHighlights();
      const gameSel = document.getElementById('filterGame');
      const saved = localStorage.getItem('selectedGame');
      const initial = (saved === 'all' || saved === 'current') ? saved : (saved && games.includes(parseInt(saved, 10)) ? saved : 'current');
      gameSel.innerHTML = '<option value="current">Current Game</option><option value="all">All Games</option>' + games.map(function(g){ return '<option value="' + g + '">Game ' + g + '</option>'; }).join('');
      gameSel.value = initial;
      localStorage.setItem('selectedGame', gameSel.value);

      await fetchRowsForSelectedGame();
      await fetchSummariesForSelectedGame();
      await fetchAllSummaries();
      await fetchResults();
      await fetchMergedSummary();

      // Initialize status and type filters
      document.getElementById('filterType').value = 'all';

      applyFiltersAndRender();

      // Wire events
      ['filterGame', 'filterSquadron', 'filterPlayer', 'filterVehicle', 'filterType'].forEach(id => {
        document.getElementById(id).addEventListener('change', async (e) => {
          if (id === 'filterGame') {
            localStorage.setItem('selectedGame', e.target.value);
            await fetchRowsForSelectedGame();
            await fetchSummariesForSelectedGame();
            await fetchAllSummaries();
            await fetchMetaForSelectedGame();
            await fetchMergedSummary();
          }
          applyFiltersAndRender();
        });
      });
      document.getElementById('btnWin').addEventListener('click', () => recordResult('win'));
      document.getElementById('btnLoss').addEventListener('click', () => recordResult('loss'));
      const postBtn = document.getElementById('btnPostLogs');
      if (postBtn) postBtn.addEventListener('click', postLogs);
      const submitBtn = document.getElementById('btnSubmitJson');
      if (submitBtn) submitBtn.addEventListener('click', submitJson);
      document.getElementById('btnSaveMeta').addEventListener('click', saveMetaForSelectedGame);
      const prevBtn = document.getElementById('btnPrevGame');
      const nextBtn = document.getElementById('btnNextGame');
      if (prevBtn) prevBtn.addEventListener('click', () => changeGameBy(-1));
      if (nextBtn) nextBtn.addEventListener('click', () => changeGameBy(1));
      // Wire status buttons
      const bAlive = document.getElementById('btnStatusAlive');
      const bDestroyed = document.getElementById('btnStatusDestroyed');
      const bReset = document.getElementById('btnStatusReset');
      function reflectStatusButtons() {
        const sel = (v) => v === statusFilter;
        if (bAlive) bAlive.classList.toggle('selected', sel('active'));
        if (bDestroyed) bDestroyed.classList.toggle('selected', sel('destroyed'));
        if (bReset) bReset.classList.toggle('selected', sel('all'));
      }
      window.setStatusFilter = function(v) {
        statusFilter = v;
        localStorage.setItem('statusFilter', v);
        reflectStatusButtons();
        applyFiltersAndRender();
      };
      if (bAlive) bAlive.addEventListener('click', () => setStatusFilter('active'));
      if (bDestroyed) bDestroyed.addEventListener('click', () => setStatusFilter('destroyed'));
      if (bReset) bReset.addEventListener('click', () => setStatusFilter('all'));
      // Initialize from saved
      try {
        const saved = localStorage.getItem('statusFilter');
        statusFilter = (saved === 'active' || saved === 'destroyed' || saved === 'all') ? saved : 'all';
      } catch (_) { statusFilter = 'all'; }
      reflectStatusButtons();
    }

    ws.onmessage = async (ev) => {
      try {
        const data = JSON.parse(ev.data);
        if (data.type === 'game') {
          // refresh games list and keep selected
          const { games } = await fetchGames();
          const gameSel = document.getElementById('filterGame');
          const prev = gameSel.value;
          gameSel.innerHTML = '<option value="current">Current Game</option><option value="all">All Games</option>' + games.map(function(g){ return '<option value="' + g + '">Game ' + g + '</option>'; }).join('');
          if (prev === 'current') { gameSel.value = 'current'; }
          else if (prev === 'all') { gameSel.value = 'all'; }
          else if (games.map(String).includes(prev)) gameSel.value = prev; else gameSel.value = String(games[games.length-1] || 'current');
          localStorage.setItem('selectedGame', gameSel.value);
          await fetchRowsForSelectedGame();
          await fetchSummariesForSelectedGame();
          await fetchAllSummaries();
          await fetchMetaForSelectedGame();
          await fetchResults();
          await fetchMergedSummary();
          applyFiltersAndRender();
        } else if (data.type === 'match' || data.type === 'destroyed' || data.type === 'update') {
          // If current selected game is active, refresh rows
          await fetchRowsForSelectedGame();
          await fetchSummariesForSelectedGame();
          await fetchAllSummaries();
          await fetchMetaForSelectedGame();
          await fetchResults();
          await fetchMergedSummary();
          applyFiltersAndRender();
        } else if (data.type === 'reset') {
          // On reset, switch to current and refresh all views
          const gameSel = document.getElementById('filterGame');
          gameSel.value = 'current';
          localStorage.setItem('selectedGame', 'current');
          await fetchRowsForSelectedGame();
          await fetchSummariesForSelectedGame();
          await fetchAllSummaries();
          await fetchMetaForSelectedGame();
          await fetchResults();
          await fetchMergedSummary();
          applyFiltersAndRender();
        }
      } catch (_) { }
    };

    // Post logs (Discord) for the selected (or current) game
    async function postLogs() {
      try {
        let game = document.getElementById('filterGame').value;
        if (game === 'all' || game === 'current') {
          const j = await (await fetch('/api/current-game')).json();
          game = String(j.currentGame);
        }
        const url = '/api/post-logs?game=' + encodeURIComponent(game);
        const resp = await fetch(url, { method: 'POST' });
        const data = await resp.json();
        if (resp.ok) {
          // Refresh views just in case something changed
          await fetchRowsForSelectedGame();
          await fetchSummariesForSelectedGame();
          await fetchAllSummaries();
          applyFiltersAndRender();
        } else {
          console.error('Failed to post logs:', data && data.error);
        }
      } catch (e) {
        console.error('Error posting logs:', e);
      }
    }

    // Submit current parsed_data.json to backend
    async function submitJson() {
      try {
        const ok = window.confirm('Submit current parsed JSON to backend?');
        if (!ok) return;
        const stateResp = await fetch('/api/state');
        if (!stateResp.ok) { console.error('Failed to read state'); return alert('Failed to read current state'); }
        const data = await stateResp.json();
        const resp = await fetch('/api/submit-json', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ data })
        });
        const j = await resp.json().catch(() => ({}));
        if (resp.ok && j && j.ok) {
          alert('JSON submitted successfully');
          // Refresh visible data after submission
          await fetchRowsForSelectedGame();
          await fetchSummariesForSelectedGame();
          await fetchAllSummaries();
          await fetchMetaForSelectedGame();
          await fetchResults();
          await fetchMergedSummary();
          applyFiltersAndRender();
        } else {
          console.error('Submit failed:', j && j.error);
          alert('Submit failed: ' + (j && j.error ? j.error : 'Unknown error'));
        }
      } catch (e) {
        console.error('Error submitting JSON:', e);
        alert('Error submitting JSON');
      }
    }

    // Reset state: clear entries and reset game counter (preserve telemetry)
    async function resetState() {
      try {
        const resp = await fetch('/api/reset', { method: 'POST' });
        const data = await resp.json();
        if (!resp.ok) {
          console.error('Failed to reset:', data && data.error);
          return;
        }
        // Switch to current game and refresh all views
        const gameSel = document.getElementById('filterGame');
        if (gameSel) {
          gameSel.value = 'current';
          localStorage.setItem('selectedGame', 'current');
        }
        await fetchRowsForSelectedGame();
        await fetchSummariesForSelectedGame();
        await fetchAllSummaries();
        await fetchMetaForSelectedGame();
        await fetchResults();
        await fetchMergedSummary();
        applyFiltersAndRender();
      } catch (e) {
        console.error('Error resetting state:', e);
      }
    }

    window.addEventListener('load', init);
    // Wire reset button after load as well
    window.addEventListener('load', function(){
      const rb = document.getElementById('btnReset');
      if (rb) rb.addEventListener('click', function(){
        const ok = window.confirm('Are you sure you want to reset? This will clear entries and reset the game counter.');
        if (ok) resetState();
      });
    });
  </script>
</head>
<body>
  <div class="container">
    <h1>War Thunder LogBot Game Log Assistant</h1>
    <div class="topnav">
      <label>Squad No: <input id="inpSquadNo" class="meta-input" type="text" placeholder="e.g. 123" /></label>
      <label>GC: <input id="inpGC" class="meta-input" type="text" placeholder="e.g. GC" /></label>
      <label>AC: <input id="inpAC" class="meta-input" type="text" placeholder="e.g. AC" /></label>
      <button id="btnSaveMeta" class="btn">Save</button>
      <a href="/settings">Settings</a>      
      <button id="btnWin" class="btn btn-win">Record Win</button>
      <button id="btnLoss" class="btn btn-loss">Record Loss</button>
      <button id="btnPostLogs">Post Logs</button>
      <button id="btnSubmitJson" class="btn">Submit JSON</button>
      <button id="btnReset" class="btn">Reset</button>
    </div>
    <h2 class="section-title">Current Game</h2>
    <div class="filters">
      <div class="game-switcher">
        <button id="btnPrevGame" class="btn" title="Previous game" type="button">◀</button>
        <select id="filterGame"></select>
        <button id="btnNextGame" class="btn" title="Next game" type="button">▶</button>
      </div>
      <select id="filterSquadron"><option value="all">All Squadrons</option></select>
      <select id="filterPlayer"><option value="all">All Players</option></select>
      <select id="filterVehicle"><option value="all">All Vehicles</option></select>
      <div class="status-switcher">
        <button id="btnStatusAlive" class="btn btn-alive" type="button" title="Show Active">Active</button>
        <button id="btnStatusDestroyed" class="btn btn-destroyed" type="button" title="Show Destroyed">Destroyed</button>
        <button id="btnStatusReset" class="btn btn-neutral" type="button" title="Show All">Both</button>
      </div>
      <select id="filterType">
        <option value="all">All Types</option>
        <option value="light tank">Light Tank</option>
        <option value="medium tank">Medium Tank</option>
        <option value="heavy tank">Heavy Tank</option>
        <option value="spg">SPG</option>
        <option value="spaa">SPAA</option>
        <option value="fighter">Fighter</option>
        <option value="attacker">Attacker</option>
        <option value="bomber">Bomber</option>
        <option value="helicopter">Helicopter</option>
        <option value="other">Other</option>
      </select>
    </div>
    <table>
      <thead>
        <tr>
          <th>Game</th>
          <th>Squadron</th>
          <th>Player</th>
          <th>Vehicle</th>
          <th>Type</th>
          <th>Status</th>
          <th>Kills</th>
        </tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>

    <h2 class="section-title">Squadron Summary (per game)</h2>
    <table class="mono-table">
      <thead>
        <tr>
          <th>Summary</th>
        </tr>
      </thead>
      <tbody id="summaryBody"></tbody>
    </table>

    <h2 class="section-title">All Games Summary (merged)</h2>
    <table class="mono-table">
      <thead>
        <tr>
          <th>Summary</th>
        </tr>
      </thead>
      <tbody id="allGamesSummaryBody"></tbody>
    </table>
  </div>
</body>
</html>
