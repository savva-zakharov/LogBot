<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>War Thunder Parsed Data</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png">
  <link rel="shortcut icon" href="/favicon.ico">
  <style>
    body { font-family: Arial, sans-serif; background: #121212; color: #e0e0e0; margin: 0; }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
    h1 { color: #4CAF50; margin: 0 0 12px 0; }
    .topnav { margin: 6px 0 16px 0; }
    .topnav a { color: #90CAF9; text-decoration: none; margin-left: 10px; }
    .topnav {
      display: flex; align-items: center; gap: 8px; flex-wrap: wrap;
    }
    .meta-input { background: #1e1e1e; color: #ddd; border: 1px solid #444; padding: 4px 6px; border-radius: 4px; width: 110px; }
    .btn { background: #2a2a2a; color: #ddd; border: 1px solid #444; padding: 6px 10px; border-radius: 4px; cursor: pointer; }
    .btn:hover { background: #333; }
    .filters { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px; }
    select { background: #1e1e1e; color: #ddd; border: 1px solid #444; padding: 6px 8px; border-radius: 4px; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 18px; }
    thead th { background: #1e1e1e; color: #aaa; padding: 8px; border-bottom: 1px solid #333; text-align: left; }
    tbody td { padding: 6px 8px; border-bottom: 1px solid #2a2a2a; }
    .status-active { color: #66BB6A; }
    .status-destroyed { color: #EF5350; }
    .section-title { margin: 16px 0 8px 0; color: #90CAF9; }
    /* Monospace summary table to preserve alignment */
    .mono-table { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .mono-table td { white-space: pre; }
  </style>
  <script>
    let rows = [];
    let summaries = [];
    let allSummaries = [];
    let highlights = { players: {}, squadrons: {} };
    const ws = new WebSocket('ws://localhost:3001');
    let gameMeta = { squadNo: '', gc: '', ac: '', game: null };
    const OUTPUT_ORDER = ['Medium','Heavy','Light','SPG','Fighter','Attacker','Bomber','Heli','SPAA'];

    async function fetchGames() {
      const [gamesResp, currentResp] = await Promise.all([
        fetch('/api/games-list'),
        fetch('/api/current-game')
      ]);
      const games = await gamesResp.json();
      const current = (await currentResp.json()).currentGame;
      return { games, current };
    }

    async function fetchMetaForSelectedGame() {
      const gameSel = document.getElementById('filterGame');
      let game = gameSel.value;
      if (game === 'current') {
        try { game = String((await (await fetch('/api/current-game')).json()).currentGame); } catch (_) {}
      }
      try {
        const res = await fetch('/api/meta' + (game && game !== 'all' ? ('?game=' + encodeURIComponent(game)) : ''));
        const j = await res.json();
        gameMeta = { game: j.game, ...(j.meta || { squadNo: '', gc: '', ac: '' }) };
      } catch (_) { gameMeta = { squadNo: '', gc: '', ac: '', game: game }; }
      // reflect into inputs
      const iSquad = document.getElementById('inpSquadNo');
      const iGc = document.getElementById('inpGC');
      const iAc = document.getElementById('inpAC');
      if (iSquad) iSquad.value = gameMeta.squadNo || '';
      if (iGc) iGc.value = gameMeta.gc || '';
      if (iAc) iAc.value = gameMeta.ac || '';
    }

    async function saveMetaForSelectedGame() {
      let game = document.getElementById('filterGame').value;
      if (game === 'current' || game === 'all') {
        try { game = String((await (await fetch('/api/current-game')).json()).currentGame); } catch (_) {}
      }
      const payload = {
        squadNo: document.getElementById('inpSquadNo').value || '',
        gc: document.getElementById('inpGC').value || '',
        ac: document.getElementById('inpAC').value || ''
      };
      try {
        await fetch('/api/meta?game=' + encodeURIComponent(game), { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        await fetchMetaForSelectedGame();
        await fetchSummariesForSelectedGame();
        applyFiltersAndRender();
      } catch (_) {}
    }

    // Load highlight colors for players and squadrons
    async function fetchHighlights() {
      try {
        const resp = await fetch('/api/highlights');
        const data = await resp.json();
        if (data && typeof data === 'object') {
          highlights = {
            players: data.players || {},
            squadrons: data.squadrons || {}
          };
        }
      } catch (_) { /* keep defaults */ }
    }

    function getColorPair(entry) {
      // Accept either string (treated as background) or object { bg, fg }
      if (!entry) return { bg: '', fg: '' };
      if (typeof entry === 'string') return { bg: entry, fg: '' };
      const bg = (entry.bg || '').trim();
      const fg = (entry.fg || '').trim();
      return { bg, fg };
    }

    // Map stored classification (Title Case, e.g. "Light Tank", "Tank destroyer")
    // to filter option value (lowercase: 'light tank', 'spg', etc.)
    function normalizeType(cls) {
      if (!cls) return 'other';
      const c = String(cls).toLowerCase();
      if (c === 'light tank') return 'light tank';
      if (c === 'medium tank') return 'medium tank';
      if (c === 'heavy tank') return 'heavy tank';
      if (c === 'tank destroyer') return 'spg';
      if (c === 'spaa') return 'spaa';
      if (c === 'fighter') return 'fighter';
      if (c === 'attacker') return 'attacker';
      if (c === 'bomber') return 'bomber';
      if (c === 'helicopter') return 'helicopter';
      return 'other';
    }

    async function fetchRowsForSelectedGame() {
      const gameSel = document.getElementById('filterGame');
      let game = gameSel.value;
      if (game === 'current') {
        try {
          const current = (await (await fetch('/api/current-game')).json()).currentGame;
          game = String(current);
        } catch (_) { /* ignore */ }
      }
      if (game === 'all') {
        // Fetch all games and aggregate
        const gamesResp = await fetch('/api/games-list');
        const games = await gamesResp.json();
        const promises = games.map(function(g){
          return fetch('/api/active-vehicles?game=' + encodeURIComponent(g))
            .then(function(r){ return r.json(); })
            .then(function(list){
              return list.map(function(item){
                if (item && (item.game === undefined || item.game === null)) {
                  item.game = g; // ensure game column present
                }
                return item;
              });
            });
        });
        const results = await Promise.all(promises);
        rows = [].concat.apply([], results);
      } else {
        // Fetch only the selected game
        const resp = await fetch('/api/active-vehicles?game=' + encodeURIComponent(game));
        rows = await resp.json();
        // ensure game column present for display
        rows = rows.map(function(item){
          if (item && (item.game === undefined || item.game === null)) {
            item.game = (isNaN(parseInt(game, 10)) ? game : parseInt(game, 10));
          }
          return item;
        });
      }
    }

    async function fetchSummariesForSelectedGame() {
      const gameSel = document.getElementById('filterGame');
      let game = gameSel.value;
      if (game === 'current') {
        const resp = await fetch('/api/current-game');
        const j = await resp.json();
        game = j.currentGame;
      } else if (game === 'all') {
        // keep as 'all' for summaries call
      }
      const params = new URLSearchParams();
      if (game !== 'all') params.set('game', game);
      const res = await fetch('/api/summaries' + (params.toString() ? ('?' + params.toString()) : ''));
      summaries = await res.json();
      // Refresh meta too to keep render in sync
      await fetchMetaForSelectedGame();
    }

    async function fetchAllSummaries() {
      try {
        const res = await fetch('/api/summaries');
        allSummaries = await res.json();
      } catch (_) { allSummaries = []; }
    }

    // Record a manual result for the selected (or current) game
    async function recordResult(kind) {
      try {
        let game = document.getElementById('filterGame').value;
        if (game === 'all' || game === 'current') {
          const j = await (await fetch('/api/current-game')).json();
          game = String(j.currentGame);
        }
        const url = '/api/result?type=' + encodeURIComponent(kind) + '&game=' + encodeURIComponent(game);
        const resp = await fetch(url, { method: 'POST' });
        const data = await resp.json();
        if (resp.ok) {
          // Refresh data views
          await fetchRowsForSelectedGame();
          await fetchSummariesForSelectedGame();
          await fetchAllSummaries();
          applyFiltersAndRender();
        } else {
          console.error('Failed to record result:', data && data.error);
        }
      } catch (e) {
        console.error('Error recording result:', e);
      }
    }

    function populateFilter(selectId, values, placeholder) {
      const sel = document.getElementById(selectId);
      const prev = sel.value;
      sel.innerHTML = '';
      const allOpt = document.createElement('option');
      allOpt.value = 'all';
      allOpt.textContent = placeholder;
      sel.appendChild(allOpt);
      values.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v;
        opt.textContent = v;
        sel.appendChild(opt);
      });
      if (values.includes(prev)) sel.value = prev; else sel.value = 'all';
    }

    function applyFiltersAndRender() {
      const game = document.getElementById('filterGame').value;
      const squadron = document.getElementById('filterSquadron').value;
      const player = document.getElementById('filterPlayer').value;
      const vehicle = document.getElementById('filterVehicle').value;
      const status = document.getElementById('filterStatus').value;
      const type = document.getElementById('filterType').value;

      const filtered = rows.filter(r => (
        (squadron === 'all' || r.squadron === squadron) &&
        (player === 'all' || r.player === player) &&
        (vehicle === 'all' || r.vehicle === vehicle) &&
        (status === 'all' || r.status === status) &&
        (type === 'all' || normalizeType(r.classification) === type)
      ));

      // Update dependent filters from filtered dataset
      const squadrons = Array.from(new Set(rows.map(r => r.squadron))).sort();
      const players = Array.from(new Set(rows.map(r => r.player))).sort();
      const vehicles = Array.from(new Set(rows.map(r => r.vehicle))).sort();
      populateFilter('filterSquadron', squadrons, 'All Squadrons');
      populateFilter('filterPlayer', players, 'All Players');
      populateFilter('filterVehicle', vehicles, 'All Vehicles');

      const tbody = document.getElementById('tableBody');
      tbody.innerHTML = filtered.map(function(r) {
        var statusClass = (r.status === 'destroyed') ? 'status-destroyed' : 'status-active';
        // Player highlight overrides squadron highlight
        var hl = getColorPair(highlights.players[r.player]) ;
        if (!hl.bg && !hl.fg) hl = getColorPair(highlights.squadrons[r.squadron]);
        var styles = [];
        if (hl.bg) styles.push('background-color: ' + hl.bg + ';');
        if (hl.fg) styles.push('color: ' + hl.fg + ';');
        var rowStyle = styles.length ? (' style="' + styles.join(' ') + '"') : '';
        return '<tr' + rowStyle + '>' +
          '<td>' + r.game + '</td>' +
          '<td>' + r.squadron + '</td>' +
          '<td>' + r.player + '</td>' +
          '<td>' + r.vehicle + '</td>' +
          '<td>' + (r.classification || 'other') + '</td>' +
          '<td class="' + statusClass + '">' + r.status + '</td>' +
          '<td>' + (r.kills || 0) + '</td>' +
        '</tr>';
      }).join('');

      // Render summaries below
      const selGame = document.getElementById('filterGame').value;
      const summaryTbody = document.getElementById('summaryBody');
      // If 'all' or 'current' is selected, summaries already contain the correct scope
      // (fetchSummariesForSelectedGame() requested the appropriate dataset),
      // so do not re-filter by the literal 'current' value.
      const view = (selGame === 'all' || selGame === 'current')
        ? summaries
        : summaries.filter(function(s){ return String(s.game) === String(selGame); });
      // group by game then sort by squadron already pre-sorted
      let html = '';
      let lastGame = null;
      view.forEach(function(s){
        var hl = getColorPair(highlights.squadrons[s.squadron]);
        var styles = [];
        if (hl.bg) styles.push('background-color: ' + hl.bg + ';');
        if (hl.fg) styles.push('color: ' + hl.fg + ';');
        var cellStyle = styles.length ? (' style="' + styles.join(' ') + '"') : '';
        if (lastGame !== s.game) {
          html += '<tr><td><strong>Game ' + s.game + '</strong></td></tr>';
          // Insert per-game meta immediately after the Game header (for selected game views)
          if (selGame !== 'all' && String(s.game) === String((gameMeta && gameMeta.game) || s.game)) {
            const meta = gameMeta || { squadNo: '', gc: '', ac: '' };
            html += '<tr><td><strong>Squad:</strong> ' + (meta.squadNo || '') + '</td></tr>';
            html += '<tr><td><strong>GC:</strong> ' + (meta.gc || '') + '</td></tr>';
            html += '<tr><td><strong>AC:</strong> ' + (meta.ac || '') + '</td></tr>';
          }
          lastGame = s.game;
        }
        // Render a single preformatted line (already padded so first | is column 7)
        html += '<tr><td' + cellStyle + '>' + s.line + '</td></tr>';
      });
      summaryTbody.innerHTML = html || '<tr><td>No data</td></tr>';

      // Render merged summary per game (one line per game)
      try {
        const tgt = document.getElementById('allGamesSummaryBody');
        if (tgt) {
          const isExcluded = (sqName) => {
            try {
              const h = highlights.squadrons[sqName];
              if (h && typeof h === 'object' && h.exclude === true) return true;
            } catch (_) {}
            return false;
          };
          // Group per game
          const grouped = new Map(); // game -> { totals, squads }
          (allSummaries || []).forEach(item => {
            if (!item || !item.counts || item.game == null) return;
            const game = Number(item.game);
            const sq = item.squadron;
            if (!sq || isExcluded(sq)) return;
            if (!grouped.has(game)) {
              const totals = {}; OUTPUT_ORDER.forEach(k => totals[k] = 0);
              grouped.set(game, { totals, squads: new Set() });
            }
            const g = grouped.get(game);
            g.squads.add(sq);
            OUTPUT_ORDER.forEach(label => { g.totals[label] = (g.totals[label] || 0) + (item.counts[label] || 0); });
          });
          // Sort by game ascending and render
          const games = Array.from(grouped.keys()).sort((a,b) => a - b);
          let mergedHtml = '';
          try {
            const meta = gameMeta || { squadNo: '', gc: '', ac: '' };
            mergedHtml += `<tr><td>Squad: ${meta.squadNo || ''}</td></tr>`;
            mergedHtml += `<tr><td>AC: ${meta.ac || ''}</td></tr>`;
            mergedHtml += `<tr><td>GC: ${meta.gc || ''}</td></tr>`;
          } catch (_) {}
          games.forEach(gm => {
            const g = grouped.get(gm);
            const sqName = (g.squads.size <= 1) ? (Array.from(g.squads)[0] || '') : 'MULT.';
            const parts = OUTPUT_ORDER.map(label => `${g.totals[label] || 0} ${label}`);
            const namePad = String(sqName).replace(/[^A-Za-z0-9]/g,'').padEnd(6,' ').slice(0,6);
            const line = `${namePad} | ${parts.join(' | ')} |`;
            mergedHtml += `<tr><td>${line}</td></tr>`;
          });
          tgt.innerHTML = mergedHtml || '<tr><td>No data</td></tr>';
        }
      } catch (_) {}
    }

    async function init() {
      const { games, current } = await fetchGames();
      await fetchHighlights();
      const gameSel = document.getElementById('filterGame');
      const saved = localStorage.getItem('selectedGame');
      const initial = (saved === 'all' || saved === 'current') ? saved : (saved && games.includes(parseInt(saved, 10)) ? saved : 'current');
      gameSel.innerHTML = '<option value="current">Current Game</option><option value="all">All Games</option>' + games.map(function(g){ return '<option value="' + g + '">Game ' + g + '</option>'; }).join('');
      gameSel.value = initial;
      localStorage.setItem('selectedGame', gameSel.value);

      await fetchRowsForSelectedGame();
      await fetchSummariesForSelectedGame();
      await fetchAllSummaries();

      // Initialize status and type filters
      document.getElementById('filterStatus').value = 'all';
      document.getElementById('filterType').value = 'all';

      applyFiltersAndRender();

      // Wire events
      ['filterGame', 'filterSquadron', 'filterPlayer', 'filterVehicle', 'filterStatus', 'filterType'].forEach(id => {
        document.getElementById(id).addEventListener('change', async (e) => {
          if (id === 'filterGame') {
            localStorage.setItem('selectedGame', e.target.value);
            await fetchRowsForSelectedGame();
            await fetchSummariesForSelectedGame();
            await fetchAllSummaries();
            await fetchMetaForSelectedGame();
          }
          applyFiltersAndRender();
        });
      });
      document.getElementById('btnWin').addEventListener('click', () => recordResult('win'));
      document.getElementById('btnLoss').addEventListener('click', () => recordResult('loss'));
      const postBtn = document.getElementById('btnPostLogs');
      if (postBtn) postBtn.addEventListener('click', postLogs);
      document.getElementById('btnSaveMeta').addEventListener('click', saveMetaForSelectedGame);
    }

    ws.onmessage = async (ev) => {
      try {
        const data = JSON.parse(ev.data);
        if (data.type === 'game') {
          // refresh games list and keep selected
          const { games } = await fetchGames();
          const gameSel = document.getElementById('filterGame');
          const prev = gameSel.value;
          gameSel.innerHTML = '<option value="current">Current Game</option><option value="all">All Games</option>' + games.map(function(g){ return '<option value="' + g + '">Game ' + g + '</option>'; }).join('');
          if (prev === 'current') { gameSel.value = 'current'; }
          else if (prev === 'all') { gameSel.value = 'all'; }
          else if (games.map(String).includes(prev)) gameSel.value = prev; else gameSel.value = String(games[games.length-1] || 'current');
          localStorage.setItem('selectedGame', gameSel.value);
          await fetchRowsForSelectedGame();
          await fetchSummariesForSelectedGame();
          await fetchAllSummaries();
          await fetchMetaForSelectedGame();
          applyFiltersAndRender();
        } else if (data.type === 'match' || data.type === 'destroyed' || data.type === 'update') {
          // If current selected game is active, refresh rows
          await fetchRowsForSelectedGame();
          await fetchSummariesForSelectedGame();
          await fetchAllSummaries();
          await fetchMetaForSelectedGame();
          applyFiltersAndRender();
        }
      } catch (_) { }
    };

    // Post logs (Discord) for the selected (or current) game
    async function postLogs() {
      try {
        let game = document.getElementById('filterGame').value;
        if (game === 'all' || game === 'current') {
          const j = await (await fetch('/api/current-game')).json();
          game = String(j.currentGame);
        }
        const url = '/api/post-logs?game=' + encodeURIComponent(game);
        const resp = await fetch(url, { method: 'POST' });
        const data = await resp.json();
        if (resp.ok) {
          // Refresh views just in case something changed
          await fetchRowsForSelectedGame();
          await fetchSummariesForSelectedGame();
          await fetchAllSummaries();
          applyFiltersAndRender();
        } else {
          console.error('Failed to post logs:', data && data.error);
        }
      } catch (e) {
        console.error('Error posting logs:', e);
      }
    }
    window.addEventListener('load', init);
  </script>
</head>
<body>
  <div class="container">
    <h1>War Thunder LogBot Game Log Assistant</h1>
    <div class="topnav">
      <label>Squad No: <input id="inpSquadNo" class="meta-input" type="text" placeholder="e.g. 123" /></label>
      <label>GC: <input id="inpGC" class="meta-input" type="text" placeholder="e.g. GC" /></label>
      <label>AC: <input id="inpAC" class="meta-input" type="text" placeholder="e.g. AC" /></label>
      <button id="btnSaveMeta" class="btn">Save</button>
      <a href="/settings">Settings</a>
    </div>
    <h2 class="section-title">Current Game</h2>
    <div class="filters">
      <select id="filterGame"></select>
      <select id="filterSquadron"><option value="all">All Squadrons</option></select>
      <select id="filterPlayer"><option value="all">All Players</option></select>
      <select id="filterVehicle"><option value="all">All Vehicles</option></select>
      <select id="filterStatus">
        <option value="all">All Status</option>
        <option value="active">Active</option>
        <option value="destroyed">Destroyed</option>
      </select>
      <select id="filterType">
        <option value="all">All Types</option>
        <option value="light tank">Light Tank</option>
        <option value="medium tank">Medium Tank</option>
        <option value="heavy tank">Heavy Tank</option>
        <option value="spg">SPG</option>
        <option value="spaa">SPAA</option>
        <option value="fighter">Fighter</option>
        <option value="attacker">Attacker</option>
        <option value="bomber">Bomber</option>
        <option value="helicopter">Helicopter</option>
        <option value="other">Other</option>
      </select>
      <button id="btnWin">Record Win</button>
      <button id="btnLoss">Record Loss</button>
      <button id="btnPostLogs">Post Logs</button>
    </div>
    <table>
      <thead>
        <tr>
          <th>Game</th>
          <th>Squadron</th>
          <th>Player</th>
          <th>Vehicle</th>
          <th>Type</th>
          <th>Status</th>
          <th>Kills</th>
        </tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>

    <h2 class="section-title">Squadron Summary (per game)</h2>
    <table class="mono-table">
      <thead>
        <tr>
          <th>Summary</th>
        </tr>
      </thead>
      <tbody id="summaryBody"></tbody>
    </table>

    <h2 class="section-title">All Games Summary (merged)</h2>
    <table class="mono-table">
      <thead>
        <tr>
          <th>Summary</th>
        </tr>
      </thead>
      <tbody id="allGamesSummaryBody"></tbody>
    </table>
  </div>
</body>
</html>
